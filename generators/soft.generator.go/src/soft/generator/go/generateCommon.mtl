[comment encoding = UTF-8 /]
[module generateCommon('http://www.eclipse.org/emf/2002/Ecore')/]

[import soft::generator::common::generateCommon/]

[query public hasGenModel(aModelElement : EModelElement) : Boolean = eAnnotations->select( source = 'http://net.masagroup/soft/2019/GenGo' )->notEmpty() /]
[query public getGenModelAnnotation(aModelElement : EModelElement) : EAnnotation = eAnnotations->select( source = 'http://net.masagroup/soft/2019/GenGo' )->first() /]

[query public hasKey(aModelElement : EModelElement, aKey:String) : Boolean = if aModelElement.hasGenModel() then aModelElement.getGenModelAnnotation().details->select(key = aKey)->notEmpty() else false endif /]
[query public valueKey(aModelElement : EModelElement, aKey:String) : String = aModelElement.getGenModelAnnotation().details->select(key = aKey)->first().value /]

[query private getFactoryName( aPackage : EPackage ) : String = aPackage.name.toUpperFirst() + 'Factory'/]
[query private getPackageName( aPackage : EPackage ) : String = aPackage.name.toUpperFirst() + 'Package'/]

[query public getInterfaceName( aClass : EClass ) : String = getInterfaceName(aClass.name,aClass.ePackage) /]
[query public getInterfaceName( aPackage : EPackage ) : String = getInterfaceName( getPackageName(),aPackage) /]
[query private getInterfaceName( aElementName : String , aPackage : EPackage ) : String = let pattern : String = aPackage.getInterfaceNamePattern() in if pattern ='' then aElementName else pattern.format(Sequence{aElementName}) endif /]
[query private getInterfaceNamePattern( aPackage : EPackage ) : String = if hasKey('interfaceNamePattern') then valueKey('interfaceNamePattern') else '' endif/]

[query public getQualifiedInterfaceName( aClass : EClass ) : String = aClass.ePackage.name + '.'  + aClass.getInterfaceName()/]
[query public getQualifiedInterfaceName( aPackage : EPackage ) : String = aPackage.name + '.' + aPackage.getInterfaceName()/]

[query public getImplementationName( aClass : EClass ) : String = getImplementationName(aClass.name,aClass.ePackage) /]
[query public getImplementationName( aPackage : EPackage ) : String = getImplementationName( getPackageName(),aPackage) /]
[query private getImplementationName( aElementName : String , aPackage : EPackage ) : String = let pattern : String = aPackage.getImplementationNamePattern() in if pattern ='' then aElementName else pattern.format(Sequence{aElementName}) endif /]
[query private getImplementationNamePattern( aPackage : EPackage ) : String = if hasKey('implementationNamePattern') then valueKey('implementationNamePattern') else '{0}Impl' endif/]

[query public getOutputFileName( aPackage : EPackage , aName : String ) : String = 
    let fileName : String = aName.toLower() in 
    let pattern : String = aPackage.getOutputFileNamePattern() in 
    if pattern ='' then fileName else pattern.format(Sequence{fileName}) endif 
/]
[query private getOutputFileNamePattern( aPackage : EPackage ) : String = if hasKey('outputFileNamePattern') then valueKey('outputFileNamePattern') else '{0}_gen.go' endif/]

[query public getterPrefix(feature : EStructuralFeature) : String = if feature.eType.name = 'EBoolean' then 'Is' else 'Get' endif/]

[query public getSetterName(feature : EStructuralFeature) : String = if hasKey('setterName') then valueKey('setterName') else 'Set'.concat(name.toUpperFirst()) endif/]
[query public getGetterName(feature : EStructuralFeature) : String = if hasKey('getterName') then valueKey('getterName') else getterPrefix().concat(name.toUpperFirst()) endif/]
[query public getUnSetterName(feature : EStructuralFeature) : String = if hasKey('unSetterName') then valueKey('unSetterName') else 'Unset'.concat(name.toUpperFirst()) endif/]
[query public getIsSetName(feature : EStructuralFeature) : String = if hasKey('isSetName') then valueKey('isSetName') else 'IsSet'.concat(name.toUpperFirst()) endif/]

[query public getMetaType(anENamedElement : ENamedElement) : String = if anENamedElement.eClass().ePackage.name ='ecore' then anENamedElement.eClass().getInterfaceName() else anENamedElement.eClass().getQualifiedInterfaceName() endif /]

[query private getMemberName(anENamedElement : ENamedElement) : String = 
    if anENamedElement.oclIsKindOf(EClassifier) then 
        anENamedElement.oclAsType(EClassifier).getMemberName() 
    else if anENamedElement.oclIsKindOf(EStructuralFeature) then 
        anENamedElement.oclAsType(EStructuralFeature).getMemberName()
    else if anENamedElement.oclIsKindOf(EOperation) then
        anENamedElement.oclAsType(EOperation).getMemberName()
    else
         anENamedElement.name.toLowerFirst()
    endif endif endif
/]
[query private getMemberName(anEClassifier : EClassifier) : String = anEClassifier.name.toLowerFirst() /]
[query private getMemberName(aStructural : EStructuralFeature) : String = aStructural.eContainingClass.name.toLowerFirst().concat('_').concat(aStructural.name.toUpperFirst()) /]
[query private getMemberName(aOperation : EOperation) : String = aOperation.eContainingClass.name.toLowerFirst().concat('_'.concat(aOperation.name.toUpperFirst()).concat(aOperation.getParameterListName())) /]
[query private getParameterListName( aOperation : EOperation) : String = if aOperation.eParameters->notEmpty() then '_'.concat(aOperation.getParameterListDetailsName()) else '' endif /]
[query private getParameterListDetailsName(aOperation : EOperation) : String = if aOperation.eParameters->size()>1 then aOperation.eParameters->first().eType.name.concat('_').concat(aOperation.eParameters->last().eType.name) else aOperation.eParameters->first().eType.name endif /]

[query public getElementAccessorName(anENamedElement : ENamedElement) : String = anENamedElement.getMemberName().toUpperFirst() /]
[query public getElementInstanceName(anENamedElement : ENamedElement) : String = anENamedElement.getMemberName() /]

[query public getShortQualifiedName( aQualifiedName : String , aNamespaceName : String ) : String =
    let aQualifiedNames : Sequence(String) = aQualifiedName.tokenize('.') in
    let aNamespaceNames : Sequence(String) = aNamespaceName.tokenize('.') in
    let shortQualifiedNames : Sequence(String) = Sequence{1..aQualifiedNames->size()}->iterate( index ; res : Sequence(String) = Sequence{} |
        let n : String = aQualifiedNames->at(index) in
        if ( res->isEmpty() and index <= aNamespaceNames->size() and (n = aNamespaceNames->at(index)) ) then
            res
        else
            res->append(n)
        endif
    ) in
    shortQualifiedNames->join('.')
/]
