[comment encoding = UTF-8 /]
[module generateFactoryImplementation('http://www.eclipse.org/emf/2002/Ecore')]

[import soft::generator::common::generateCommon/]
[import soft::generator::go::generateCommon/]
[import soft::generator::go::lib::generateCommon/]
[import soft::generator::go::lib::impl::generateCommon/]
[import soft::generator::go::lib::factory::generateCommon/]

[template public generateFactoryImplementation(anEPackage : EPackage) { className : String = anEPackage.getFactoryImplementationName() ; }]
[file (anEPackage.getOutputDirectory() + '/' + className.toLower() + '_gen.go', false, 'UTF-8')]
package [anEPackage.name/]

import "log"

type [anEPackage.getFactoryImplementationName()/] struct {
}

[anEPackage.generateFactoryImplementationMember()/] Create(eClass EClass) EObject {
	classID := eClass.GetClassifierID()
	switch classID {
    [for (aClass : EClass | anEPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name)) ? (aClass.abstract=false)]
    case [aClass.getClassifierIDName()/]:
        return [anEPackage.getFactoryReceiverTypeName()/].Create[aClass.name/]();
    [/for]
    default:
        log.Fatalln("Create: ", classID, " not found")
	}
	return nil
}

[for (aClass : EClass | anEPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name)) ? (aClass.abstract=false)]
[anEPackage.generateFactoryImplementationMember()/] Create[aClass.name/]() [aClass.getInterfaceName()/] {
	element := New[getImplementationName(aClass)/]()
    return element
}
[let ref : OrderedSet(EReference) = aClass.getAllContainers()]
[for(aReference:EReference | ref->sortedBy(name))]
[anEPackage.generateFactoryImplementationMember()/] Create[aClass.name/]FromContainer(eContainer [aReference.eGenericType.eClassifier.name/]) [aClass.getInterfaceName()/] {
    [generateCreateFunctionContent(aClass, aReference, false)/]
}
[if(aClass.getElementIDAccessorName().size() > 0)]
[anEPackage.generateFactoryImplementationMember()/] Create[aClass.name/]FromContainerAndClassID(eContainer [aReference.eGenericType.eClassifier.name/], classID int) [aClass.getInterfaceName()/] {
    [generateCreateFunctionContent(aClass, aReference, true)/]
}
[/if]
[/for]
[/let]
[/for]
[let dataTypes : Sequence(EDataType) = anEPackage.eAllContents(EDataType)->select( serializable )->sortedBy(name)]
[anEPackage.generateFactoryImplementationMember()/] CreateFromString(eDataType EDataType, literalValue string) interface{} {
	classID := eDataType.GetClassifierID()
	switch classID {
    [for (aDataType : EDataType | dataTypes)]
    case [aDataType.getClassifierIDName()/]:
        return ecoreFactoryImpl.Create[aDataType.name/]FromString(eDataType, literalValue)
    [/for]
    default:
        log.Fatalln("The datatype '", eDataType.GetName(), "' is not a valid classifier")
	}
	return nil
}

[anEPackage.generateFactoryImplementationMember()/] ConvertToString(eDataType EDataType, instanceValue interface{}) string {
    classID := eDataType.GetClassifierID()
    switch classID {
[for (aDataType : EDataType | dataTypes)]
    case [aDataType.getClassifierIDName()/]:
        return ecoreFactoryImpl.Convert[aDataType.name/]ToString(eDataType, instanceValue)
[/for]
    default:
        log.Fatalln("The datatype '", eDataType.GetName(), "' is not a valid classifier")
    }
}
[for (aDataType : EDataType | dataTypes)]
[let createMethodName : String = 'Create' + aDataType.name + 'FromString']
[anEPackage.generateFactoryImplementationMember()/] [createMethodName/](eDataType EDataType, literalValue string) interface{} {
	log.Fatal("NotImplementedException")
}
[/let]
[let convertMethodName : String = 'Convert' + aDataType.name + 'ToString']
[anEPackage.generateFactoryImplementationMember()/] [convertMethodName/](eDataType EDataType, literalValue string) interface{} {
	log.Fatal("NotImplementedException")
}
[/let]
[/for]
[/let]
func Get[anEPackage.getFactoryImplementationName()/]() [anEPackage.getFactoryImplementationName()/] {
	return [anEPackage.getFactoryImplementationName()/]Instance
}

var [anEPackage.getFactoryImplementationName()/]Instance = &[anEPackage.getFactoryImplementationName()/]{}
[/file]
[/template]

[template public generateCreateFunctionContent(aClass : EClass, aReference : EReference, addID : Boolean)]
element := New[aClass.name/]Impl()
[if(addID)]
element.Set[aClass.getElementIDAccessorName()/]ID(classID)
[/if]
[if(not aReference.eOpposite.name.oclIsUndefined())]
if eContainer != nil {
[if(aReference.eOpposite.upperBound <> 1)]
    eContainer.Get[aReference.eOpposite.name.toUpperFirst()/]().Add(element)
[else]
    eContainer.Set[aReference.eOpposite.name.toUpperFirst()/](element)
[/if]
}
[/if]
return element
[/template]
