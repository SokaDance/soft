[comment encoding = UTF-8 /]
[module generateImplementationSource('http://www.eclipse.org/emf/2002/Ecore')]

[import soft::generator::cpp::generateCommon /]
[import soft::generator::cpp::generateClass/]
[import soft::generator::cpp::generateOperation/]
[import soft::generator::cpp::generateType/]
[import soft::generator::cpp::generateStructuralFeature /]
[import soft::generator::cpp::lib::generateCommon /]
[import soft::generator::cpp::lib::generateInterface /]
[import soft::generator::cpp::lib::impl::generateReflectives /]


[template public generateImplementationSource(aClass : EClass) { className : String = aClass.getImplementationName(); namespaceName : String = aClass.ePackage.getImplementationNamespaceName();}]
[file (aClass.ePackage.getOutputDirectory() + '/src-gen/' + aClass.ePackage.getImplementationFolder() + '/' + className + '.cpp', false, 'UTF-8')]
[fileComment()/]
#include "[namespaceToFolder(aClass.getQualifiedImplementationName())/].hpp"
[let includes : OrderedSet(String) = Set{ aClass.getClassIncludes()->selectByKind(EClass)->collect( c | c.getQualifiedInterfaceName())->asSet()
                                        , Set {
                                                    aClass.ePackage.getQualifiedInterfaceName(),
                                                    aClass.ePackage.getFactoryQualifiedInterfaceName(),
                                                    aClass.eClass().ePackage.getQualifiedInterfaceName(),
                                                    aClass.eClass().ePackage.getFactoryQualifiedInterfaceName(),
                                                    'ecore::EAnnotation',
                                                    'ecore::EClass',
                                                    'ecore::EAttribute',
                                                    'ecore::EStructuralFeature',
                                                    'ecore::impl::EObjectEList'
                                              }
                                        }->flatten()->asOrderedSet()->sortedBy( s | s)]
[for ( include : String | includes )]
#include "[namespaceToFolder(include)/].hpp"
[/for]
[/let]
[generateAbstractDataTypesIncludes()/]

#include <cassert>
#include <iostream>
#include <sstream>
[if (aClass.eAttributes.eType->select(isAny())->size() = 0 and aClass.eOperations.eParameters.eType->select(isAny())->size() > 0)]
#include <boost/any.hpp>
[/if]

//[protected (className + ' [declaration-includes]')]
//[/protected]


[comment namespace /]
[let namespaces : OrderedSet(String) = OrderedSet{ 'ecore' , aClass.ePackage.getInterfaceNamespaceName() , aClass.ePackage.getImplementationNamespaceName()}]
[for (namespace : String | namespaces )]
using namespace [namespace/];
[/for]
[/let]

//[protected (className + ' [declaration-begin]')]
//[/protected]

//*********************************
// Constructor / Destructor
//*********************************
//[protected (className+ '::' + className)]
[className/]::[className/]()
{
}
//[/protected]

//[protected (className+ '::~' + className)]
[className/]::~[className/]()
{
#ifdef SHOW_DELETION
    std::cout << "-------------------------------------------------------------------------------------------------\r\ndelete [aClass.name.toUpperFirst()/] "<< this << "\r\n------------------------------------------------------------------------ " << std::endl;
#endif
}
//[/protected]

std::shared_ptr<EClass> [className/]::eStaticClass() const
{
    return [aClass.ePackage.getInterfaceName()/]::eInstance()->get[aClass.getElementAccessorName()/]();
}

[aClass.generateGetThisPtrCPP()/]

[let operations : OrderedSet(EOperation) = aClass.eOperations->select( isPublic(true) )]
[if operations->notEmpty()]
//*********************************
// Operations
//*********************************
[operations.generateDefinition()/]
[/if]
[/let]
[let attributes : OrderedSet(EAttribute) = aClass.eStructuralFeatures->selectByKind(EAttribute)->select( hasSetter('public',true) or hasGetter('public',true) )]
[if attributes->notEmpty()]
//*********************************
// Attributes
//*********************************
[attributes.generateDefinition()/]
[/if]
[/let]
[let references : OrderedSet(EAttribute) = aClass.eStructuralFeatures->selectByKind(EReference)->select( hasSetter('public',true) or hasGetter('public',true)  )]
[if references->notEmpty()]
//*********************************
// References
//*********************************
[references.generateDefinition()/]
[/if]
[/let]
[let basicFeatures : OrderedSet(EAttribute) = aClass.eStructuralFeatures->select( isBasicGet() or isBasicSet() )]
[if basicFeatures->notEmpty()]
//*********************************
// Basics
//*********************************
[basicFeatures.generateBasicDefinition()/]
[/if]
[/let]
[aClass.generateReflectivesDefinition()/]
// [protected (className + ' [declaration-end]') ]
// [/protected]

[/file]
[/template]
