[comment encoding = UTF-8 /]
[module generateReference('http://www.eclipse.org/emf/2002/Ecore')]

[import soft::generator::cpp::generateType /]
[import soft::generator::cpp::utils /]



[query public hasSetter(anEReference : EReference) : EBoolean = (anEReference.changeable and anEReference.upperBound=1) or hasKey('setterbody') /]
[query public hasGetter(anEReference : EReference) : EBoolean = not hasKey('noGetter') or hasKey('getterbody') /]


[template public generateReferenceDeclaration(anEReference : EReference, impl : EBoolean) ]
[anEReference.generateReferenceGetterDeclaration(impl)/]
[anEReference.generateReferenceSetterDeclaration(impl)/]
[/template]

[template public generateReferenceGetterDeclaration(anEReference : EReference, impl : EBoolean)? (hasGetter() and (not isUnion()) )]
virtual [anEReference.generateReferenceType()/] [anEReference.getGetterName()/]() const [abstractSufix(impl)/];

[/template]

[template public generateReferenceSetterDeclaration(anEReference : EReference, impl : EBoolean) ? ( hasSetter() )]
virtual void [anEReference.getSetterName()/]([if (not anEReference.eGenericType.oclIsKindOf(EDataType))]
[generateReferenceParameter(anEReference)/][else]
[anEReference.eGenericType.generateCppType()/][/if]
[anEReference.name/]) [abstractSufix(impl)/];


[/template]

[template public generateReferenceParameter(anEReference : EReference)]
[if(anEReference.upperBound = 1)]
std::shared_ptr<[anEReference.eGenericType.generateCppType()/]> [anEReference.name/][else]
std::shared_ptr<EList<[anEReference.eGenericType.generateCppType()/]> > [anEReference.name/][/if]
[/template]

[template public generateReferenceProtected(anEReference : EReference) ]
[anEReference.generateReferenceType()/] [anEReference.name/]_;

[/template]

[template public generateReferenceInit(eReference : EReference)? (not(eReference.upperBound=1))]
    [eReference.name/]_.reset(new EList<[eReference.eGenericType.generateCppType()/]>());
[/template]

[template public generateReferenceCpp(anEReference : EReference)]
[anEReference.generateReferenceGetterCpp()/]
[anEReference.generateReferenceSetterCpp()/]
[/template]

[template public generateReferenceSetterCpp(anEReference : EReference) ? (hasSetter())]
void [anEReference.eContainingClass.name.toUpperFirst()/]Impl::[anEReference.getSetterName()/]([generateReferenceParameter(anEReference)/])
{
[if (hasKey('setterbody'))]
//generated from setterbody annotation
[valueKey('setterbody')/] 
//end of body
[else]
    [anEReference.name/]_ = [anEReference.name/];
[/if]
}
[/template]

[template public generateReferenceGetterCpp(anEReference : EReference) ? (hasGetter()and (not isUnion()))]
[anEReference.generateReferenceType()/] [anEReference.eContainingClass.name.toUpperFirst()/]Impl::[anEReference.getGetterName()/]() const
{
[if (hasKey('getterbody'))]
//generated from getterbody annotation
[valueKey('getterbody')/]
//end of body
[else]
[if(anEReference.lowerBound>0)]//assert([anEReference.name/]_);[/if]
    return [anEReference.name/]_;
[/if]
}
[/template]

[template public generateStaticReferenceID(anEReference : EReference)]
static const int [anEReference.getStaticAttributeIDName()/] = [anEReference.eContainingClass.getMyClassifierID() * 100 + anEReference.getFeatureID()/];

[/template]

[template public generateReferenceCreation(anEReference : EReference)]
[anEReference.getClassMemberName()/] = factory->createEReference([anEReference.eContainingClass.getClassMemberName()/], [anEReference.getStaticAttributeIDName()/]);

[/template] 
 
[template public generateReferenceInitialization(anEReference : EReference)]
[anEReference.getClassMemberName()/]->setName("[anEReference.name/]");
[anEReference.getClassMemberName()/]->setEType([anEReference.eGenericType.eClassifier.packageGetter(anEReference)/]);
[anEReference.getClassMemberName()/]->setLowerBound([anEReference.lowerBound/]);
[anEReference.getClassMemberName()/]->setUpperBound([anEReference.upperBound/]);
[anEReference.getClassMemberName()/]->setTransient([anEReference.transient.toString()/]);
[anEReference.getClassMemberName()/]->setVolatile([anEReference.volatile.toString()/]);
[anEReference.getClassMemberName()/]->setChangeable([anEReference.changeable.toString()/]);
[anEReference.getClassMemberName()/]->setUnsettable([anEReference.unsettable.toString()/]);
[anEReference.getClassMemberName()/]->setUnique([anEReference.unique.toString()/]);
[anEReference.getClassMemberName()/]->setDerived([anEReference.derived.toString()/]);
[anEReference.getClassMemberName()/]->setOrdered([anEReference.ordered.toString()/]);
[anEReference.getClassMemberName()/]->setContainment([anEReference.containment.toString()/]);
[anEReference.getClassMemberName()/]->setResolveProxies([anEReference.resolveProxies.toString()/]);
{
	std::string defaultValue = "[anEReference.defaultValueLiteral/]";
	if (!defaultValue.empty())
	{
		[anEReference.getClassMemberName()/]->setDefaultValueLiteral(defaultValue);
	}
	std::shared_ptr<ecore::EReference>  otherEnd = [anEReference.eOpposite.getPackageGetter()/];
	if (otherEnd != nullptr)
    {
   		[anEReference.getClassMemberName()/]->setEOpposite(otherEnd);
    }
}

[/template]
