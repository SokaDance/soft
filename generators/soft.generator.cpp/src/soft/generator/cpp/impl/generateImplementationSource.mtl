[comment encoding = UTF-8 /]
[module generateImplementationSource('http://www.eclipse.org/emf/2002/Ecore')]

[import soft::generator::cpp::generateAttribute/]
[import soft::generator::cpp::generateClass/]
[import soft::generator::cpp::generateOperation/]
[import soft::generator::cpp::generateReference/]
[import soft::generator::cpp::generateStructuralFeature/]
[import soft::generator::cpp::generateType/]
[import soft::generator::cpp::generateInterface /]
[import soft::generator::cpp::utils /]

[template public generateImplementationSource(aClass : EClass) { className : String = aClass.name.toUpperFirst().concat('Impl'); }]
[file ('src-gen/'.concat(aClass.ePackage.name).concat('/impl/').concat(className).concat('.cpp'), false, 'UTF-8')]
#include "[aClass.ePackage.name/]/impl/[className.concat('.hpp')/]"

#include <cassert>
#include <iostream>
#include <sstream>

[generateAbstractDataTypesIncludes()/]
[if (aClass.eAttributes.eType->select(requiresAny())->size() = 0 and aClass.eOperations.eParameters.eType->select(requiresAny())->size() > 0)]
#include <boost/any.hpp>
[/if]
#include "ecore/EAnnotation.hpp"
#include "ecore/EClass.hpp"
#include "[aClass.ePackage.name/]/impl/[aClass.ePackage.name.toUpperFirst().concat('PackageImpl')/].hpp"
[if (aClass.hasKey('includes'))]
[aClass.valueKey('includes')/]
[/if]


[for (element : EClassifier| aClass.includes()->selectByKind(EClass)->asOrderedSet()->sortedBy(name)) separator ('\n')]
#include "[element.ePackage.name/]/[element.name.toUpperFirst()/].hpp"
[/for]

#include "[aClass.eClass().ePackage.name/]/[aClass.eClass().ePackage.name.toUpperFirst()/]Package.hpp"
#include "[aClass.eClass().ePackage.name/]/[aClass.eClass().ePackage.name.toUpperFirst()/]Factory.hpp"
#include "[aClass.ePackage.name/]/[aClass.ePackage.name.toUpperFirst()/]Package.hpp"
#include "[aClass.ePackage.name/]/[aClass.ePackage.name.toUpperFirst()/]Factory.hpp"
#include "ecore/EAttribute.hpp"
#include "ecore/EStructuralFeature.hpp"

[comment namespace /]
using namespace [aClass.ePackage.name/];

//*********************************
// Constructor / Destructor
//*********************************
[className/]::[className/]()
{
    //*********************************
    // Attribute Members
    //*********************************
    [for (aAttribute : EAttribute | aClass.eAttributes->asOrderedSet()->sortedBy(name)) separator ('\n')]
    [aAttribute.generateAttributeInit()/][/for]

    //*********************************
    // Reference Members
    //*********************************
    [for (aReference : EReference | aClass.eReferences->asOrderedSet()->sortedBy(name)) separator ('\n')]
    [aReference.generateReferenceInit()/]
    [/for]

}

[className/]::~[className/]()
{
#ifdef SHOW_DELETION
    std::cout << "-------------------------------------------------------------------------------------------------\r\ndelete [aClass.name.toUpperFirst()/] "<< this << "\r\n------------------------------------------------------------------------ " << std::endl;
#endif
}


[let ref:OrderedSet(EReference) = aClass.getAllContainers()]
[for(aReference:EReference | ref->sortedBy(name)) separator('\n')]
//Additional constructor for the containments back reference
[if(ref->select(eType.name = aReference.eType.name)->size()>1 )]
    [if(ref->select(eType.name = aReference.eType.name)->asOrderedSet()->sortedBy(name)->first() = aReference)]
            [className/]::[className/]([aReference.generateReferenceType(true)/] par_[aReference.eType.name/], const int reference_id)
            :[className/]()
            {
                switch(reference_id)
                {   
                [for(multipleRef : EReference | ref->select(eType.name = aReference.eType.name)->sortedBy(name))]
                case [aClass.ePackage.name.toUpperFirst()/]Package::[multipleRef.getStaticAttributeIDName()/]:
                    [multipleRef.name/]_ = par_[aReference.eType.name/];
                    return;
                [/for]
                default:
                std::cerr << __PRETTY_FUNCTION__ <<" Reference not found in class with the given ID" << std::endl;
                }
               
            }
    [/if]
    [else]
            [className/]::[className/]([aReference.generateReferenceType(true)/] par_[aReference.name/])
            :[className/]()
            {
                [aReference.name/]_ = par_[aReference.name/];
            }
    [/if]




[/for]
[/let]


[comment]Don't forget to call the class contructor before initializing the unions and subsets![/comment]
[className/]::[className/](const [className/] & obj):[className/]()
{
    //create copy of all Attributes
    #ifdef SHOW_COPIES
    std::cout << "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\ncopy [aClass.name.toUpperFirst()/] "<< this << "\r\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ " << std::endl;
    #endif
    [for (att : EAttribute | aClass.eAllAttributes->asOrderedSet()->sortedBy(name))]
    [att.name/]_ = obj.[att.getGetterName()/]();
    [/for]

    //copy references with no containment (soft copy)
    
    [for (ref : EReference | aClass.eAllReferences->select(aRef: EReference | aRef.isBackReference() or (aRef.containment = false))->asOrderedSet()->sortedBy(name))]
    [if (ref.hasSetter() or ref.upperBound = 1)]
    [ref.name/]_  = obj.[ref.getGetterName()/]();
    [else]
    [ref.name/]_.reset(new [ref.generateReferenceType(false)/](*(obj.[ref.getGetterName()/]().get())));
    [/if]

    [/for]

    //Clone references with containment (deep copy)

    [for (ref : EReference | aClass.eAllReferences->select(eRef: EReference|(eRef.containment = true) and (not eRef.isUnion()) and (not eRef.isBackReference()))->asOrderedSet()->sortedBy(name))]
    [if (ref.hasSetter() or ref.upperBound = 1)]
    if(obj.[ref.getGetterName()/]()!=nullptr)
    {
        [if(ref.upperBound=1)]
        [ref.name/]_ = std::dynamic_pointer_cast<[ref.eType.generateType()/]>(obj.[ref.getGetterName()/]()->copy());
        [else]
        [ref.name/]_ = std::dynamic_pointer_cast<Bag<[ref.eType.generateType()/]>>(obj.[ref.getGetterName()/]()->copy());
        [/if]
    }
    [else]
    std::shared_ptr<EList<[ref.eType.generateType()/]>> [ref.name/]List = obj.[ref.getGetterName()/]();
    for(std::shared_ptr<[ref.eType.generateType()/]> [ref.name/] : *[ref.name/]List)
    {
        this->[ref.getGetterName()/]()->add(std::shared_ptr<[ref.eType.generateType()/]>(std::dynamic_pointer_cast<[ref.eType.generateType()/]>([ref.name/]->copy())));
    }
    [/if]
    [/for]

}

std::shared_ptr<ecore::EObject>  [className/]::copy() const
{
    std::shared_ptr<[className/]> element(new [className/](*this));
    element->[generateGetThisPtrPropertySetterName()/](element);
    return element;
}

std::shared_ptr<[needNamespace(aClass.ePackage, 'EClass')/]> [className/]::eStaticClass() const
{
    return [aClass.ePackage.name.concat('PackageImpl').toUpperFirst()/]::eInstance()->get[aClass.getMemberNameUpperFirst()/]();
}

//*********************************
// Attribute Setter Getter
//*********************************
[for (aAttribute : EAttribute | aClass.eAttributes->asOrderedSet()->sortedBy(name)) separator ('\n')]
[aAttribute.generateAttributeSetterImplementationCpp(true)/]

[aAttribute.generateAttributeGetterImplementationCpp()/]
[/for]

//*********************************
// Operations
//*********************************
[for (aOperation : EOperation | aClass.eOperations->asOrderedSet()->sortedBy(name)) separator ('\n')]
[aOperation.generateOperationImplementation()/]
[/for]

//*********************************
// References
//*********************************
[for (aReference : EReference | aClass.eReferences->asOrderedSet()->sortedBy(name)) separator ('\n')]
[aReference.generateReferenceCpp()/]
[/for]


[aClass.generateGetThisPtrCPP()/]
[aClass.generateEContainerOperationCPP()/]

//*********************************
// Structural Feature Getter/Setter
//*********************************
[aClass.generateGetImpl()/]
[aClass.generateIsSetImpl()/]
[aClass.generateSetImpl()/]


[/file]
[/template]