[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateStructuralFeature('http://www.eclipse.org/emf/2002/Ecore')]

[import soft::generator::cpp::utils /]
[import soft::generator::cpp::generateAttribute /]
[import soft::generator::cpp::generateType /]
[import soft::generator::cpp::generateReference /]

[**
 * eGet Function
*/]
[template public generateGetDel(aClass : EClass,impl : Boolean)]
virtual std::shared_ptr<boost::any> eGet(int featureID, bool resolve, bool coreType) const [abstractSufix(impl)/];
[/template]

[template public generateIsSetDel(aClass : EClass,impl : Boolean)]
virtual bool internalEIsSet(int featureID) const [abstractSufix(impl)/];
[/template]

[template public generateSetDel(aClass : EClass,impl : Boolean)]
virtual bool eSet(int featureID, std::shared_ptr<boost::any> newValue) [abstractSufix(impl)/];
[/template]

[template public generateGetImpl(aClass : EClass)]
std::shared_ptr<boost::any> [aClass.name.toUpperFirst().concat('Impl')/]::eGet(int featureID, bool resolve, bool coreType) const
{
    switch(featureID)
    {
    [for (struct : EStructuralFeature | aClass.eStructuralFeatures->asOrderedSet()->sortedBy(name))]
        case [struct.getMetaModelPackageNameForEStructuralFeature(aClass)/]::[struct.getStaticAttributeIDName()/]:
            return eAny([struct.getGetterName()/]()); //[aClass.getMyClassifierID()/][struct.getFeatureID()/]
    [/for]
    }
[if (aClass.eSuperTypes->isEmpty() and not (aClass.name ='EObject'))]
    return ecore::EObjectImpl::eGet(featureID, resolve, coreType);
[elseif (aClass.eSuperTypes->size() = 1)]
    return [getClassWithNamespace(aClass, aClass.eSuperTypes->first())/]Impl::eGet(featureID, resolve, coreType);
[else]
    std::shared_ptr<boost::any> result;
    [let eClasses : OrderedSet(EClass) = aClass.eSuperTypes->asOrderedSet()->sortedBy(name)]        
    [for (sClass : EClass | eClasses)]
    result = [getClassWithNamespace(aClass,sClass)/]Impl::eGet(featureID, resolve, coreType);
    [if (sClass <> eClasses->last())]
    if (!result->isEmpty())
    {
        return result;
    }
    [/if]
    [/for]
    return result;
    [/let]
[/if]
}
[/template]

[template public generateIsSetImpl(aClass : EClass)]
bool [aClass.name.toUpperFirst().concat('Impl')/]::internalEIsSet(int featureID) const
{
    switch(featureID)
    {
    [for (struct : EStructuralFeature | aClass.eStructuralFeatures->asOrderedSet()->sortedBy(name))]
        case [struct.getMetaModelPackageNameForEStructuralFeature(aClass)/]::[struct.getStaticAttributeIDName()/]:
            return [struct.generateComparison()/]; //[aClass.getMyClassifierID()/][struct.getFeatureID()/]
    [/for]
    }
[if (aClass.eSuperTypes->isEmpty() and not (aClass.name ='EObject'))]
    return ecore::EObjectImpl::internalEIsSet(featureID);
[elseif (aClass.eSuperTypes->size() = 1)]
    return [getClassWithNamespace(aClass, aClass.eSuperTypes->first())/]Impl::internalEIsSet(featureID);
[else]
    bool result = false;
    [let eClasses : OrderedSet(EClass) = aClass.eSuperTypes->asOrderedSet()->sortedBy(name)]        
    [for (sClass : EClass | eClasses)]
    result = [getClassWithNamespace(aClass,sClass)/]Impl::internalEIsSet(featureID);
    [if (sClass <> eClasses->last())]
    if (result)
    {
        return result;
    }
    [/if]
    [/for]
    return result;
    [/let]
[/if]
}
[/template]

[template public generateSetImpl(aClass : EClass)]
bool [aClass.name.toUpperFirst().concat('Impl')/]::eSet(int featureID, std::shared_ptr<boost::any> newValue)
{
    switch(featureID)
    {
[for (struct : EStructuralFeature | aClass.eStructuralFeatures->select(upperBound = 1 and changeable)->asOrderedSet()->sortedBy(name))]
        case [struct.getMetaModelPackageNameForEStructuralFeature(aClass)/]::[struct.getStaticAttributeIDName()/]:
        {
            // BOOST CAST
[if (not struct.eType.oclIsKindOf(EDataType))]
            std::shared_ptr<[struct.eGenericType.generateCppType()/]> _[struct.name/] = newValue->get<std::shared_ptr<[struct.eGenericType.generateCppType()/]>>();
[else]
            [struct.eGenericType.generateCppType()/] _[struct.name/] = newValue->get<[struct.eGenericType.generateCppType()/]>();
[/if]
            [struct.getSetterName()/](_[struct.name/]); //[aClass.getMyClassifierID()/][struct.getFeatureID()/]
            return true;
        }
[/for]
    }

[if (aClass.eSuperTypes->isEmpty() and not (aClass.name ='EObject'))]
    return ecore::EObjectImpl::eSet(featureID, newValue);
[elseif (aClass.eSuperTypes->size() = 1)]
    return [getClassWithNamespace(aClass, aClass.eSuperTypes->first())/]Impl::eSet(featureID, newValue);
[else]
    bool result = false;
    [let eClasses : OrderedSet(EClass) = aClass.eSuperTypes->asOrderedSet()->sortedBy(name)]        
    [for (sClass : EClass | eClasses)]
    result = [getClassWithNamespace(aClass,sClass)/]Impl::eSet(featureID, newValue);
    [if (sClass <> eClasses->last())]
    if (result)
    {
        return result;
    }
    [/if]
    [/for]
    return result;
    [/let]
[/if]
}
[/template]

[template public generateComparison(anStructFeature : EStructuralFeature) ? (oclIsKindOf(EAttribute) and not eType.requiresAny()) post (trim())]
[if (anStructFeature.upperBound <> 1)]
![anStructFeature.getGetterName()/]()->empty()
[elseif (eType.oclIsKindOf(EEnum))]
[anStructFeature.name/]_ ![anStructFeature.oclAsType(EAttribute).generateDefaultValue()/];
[else]
[anStructFeature.getGetterName()/]() != [anStructFeature.oclAsType(EAttribute).getDefaultValue()/]
[/if]
[/template]

[template public generateComparison(anStructFeature : EStructuralFeature) ? (not oclIsKindOf(EAttribute) and not eType.requiresAny())]
[anStructFeature.getGetterName()/]()[if (anStructFeature.oclIsKindOf(EReference))][if(anStructFeature.oclAsType(EReference).isBackReference())].lock()[/if][/if] != [anStructFeature.eType.getDefaultValue()/]
[/template]

[template public generateComparison(anStructFeature : EStructuralFeature) ? (eType.requiresAny())]
![anStructFeature.getGetterName()/]()->isEmpty()
[/template]