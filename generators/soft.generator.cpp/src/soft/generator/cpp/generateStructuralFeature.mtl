[comment encoding = UTF-8 /]
[module generateStructuralFeature('http://www.eclipse.org/emf/2002/Ecore')]

[import soft::generator::cpp::generateAttribute /]
[import soft::generator::cpp::generateCommon /]
[import soft::generator::cpp::generateType /]
[import soft::generator::cpp::generateClass /]


[query private getEGetFeatures(aClass : EClass) : Set(EStructuralFeature) = aClass.eStructuralFeatures/]
[query private getESetFeatures(aClass : EClass) : Set(EStructuralFeature) = aClass.eStructuralFeatures->select( eFeature | eFeature.isSet())/]
[query private getEIsSetFeatures(aClass : EClass) : Set(EStructuralFeature) = aClass.getEGetFeatures()/]
[query private getEUnSetFeatures(aClass : EClass) : Set(EStructuralFeature) = aClass.getESetFeatures()/]
[query private getEInverseAddFeatures(aClass : EClass) : Set(EStructuralFeature) = aClass.eStructuralFeatures->select( eFeature | eFeature.isBidirectional() and not eFeature.isVolatile())/]
[query private getEInverseRemoveFeatures(aClass : EClass) : Set(EStructuralFeature) = aClass.eStructuralFeatures->select( eFeature | eFeature.isContains() or (eFeature.isBidirectional() and not eFeature.isVolatile()))/]

[**
 * eGet Function
*/]
[template public generateGetDeclaration(aClass : EClass,impl : Boolean) ? (aClass.getEGetFeatures()->notEmpty()) post (trim())]
virtual boost::any eGet(int featureID, bool resolve, bool coreType) const [abstractSufix(impl)/];
[/template]

[template public generateIsSetDeclaration(aClass : EClass,impl : Boolean) ? (aClass.getEIsSetFeatures()->notEmpty()) post (trim())]
virtual bool eIsSet(int featureID) const [abstractSufix(impl)/];
[/template]

[template public generateSetDeclaration(aClass : EClass,impl : Boolean) ? (aClass.getESetFeatures()->notEmpty()) post (trim())]
virtual void eSet(int featureID, const boost::any& newValue) [abstractSufix(impl)/];
[/template]

[template public generateUnSetDeclaration(aClass : EClass,impl : Boolean) ? (aClass.getEUnSetFeatures()->notEmpty()) post (trim())]
virtual void eUnSet(int featureID) [abstractSufix(impl)/];
[/template]

[template public generateInvokeDeclaration(aClass : EClass,impl : Boolean) ? (aClass.eOperations->notEmpty()) post (trim())]
virtual boost::any eInvoke( int operationID, const std::shared_ptr<EList<boost::any>>& arguments )[abstractSufix(impl)/];
[/template]

[template public generateInverseAddDeclaration(aClass : EClass,impl : Boolean) ? (aClass.getEInverseAddFeatures()->notEmpty()) post (trim())]
virtual std::shared_ptr<ENotificationChain> eBasicInverseAdd( const std::shared_ptr<EObject>& otherEnd, int featureID, const std::shared_ptr<ENotificationChain>& notifications )[abstractSufix(impl)/];
[/template]

[template public generateInverseRemoveDeclaration(aClass : EClass,impl : Boolean) ? (aClass.getEInverseRemoveFeatures()->notEmpty()) post (trim())]
virtual std::shared_ptr<ENotificationChain> eBasicInverseRemove( const std::shared_ptr<EObject>& otherEnd, int featureID, const std::shared_ptr<ENotificationChain>& notifications )[abstractSufix(impl)/];
[/template]


[template public generateGetImplementation(aClass : EClass) ? (aClass.getEGetFeatures()->notEmpty()) post (trim())]
[let className : String = aClass.getImplementationName()]
boost::any [className/]::eGet(int featureID, bool resolve, bool coreType) const
{
    switch(featureID)
    {
    [for (anStructFeature : EStructuralFeature | aClass.eStructuralFeatures->asOrderedSet()->sortedBy(name))]
        case [anStructFeature.getMetaModelPackageNameForEStructuralFeature(aClass)/]::[anStructFeature.eContainingClass.getFeatureIDName(anStructFeature)/]:
            return [anStructFeature.getGetterName()/]();
    [/for]
    }
    return [removeNamespace(aClass.getClassExtends())/]::eGet(featureID, resolve, coreType);
}
[/let]
[/template]

[template public generateIsSetImplementation(aClass : EClass) ? (aClass.getEIsSetFeatures()->notEmpty()) post (trim())]
[if aClass.getEIsSetFeatures()->select( eFeature : EStructuralFeature | eFeature.oclIsKindOf(EReference) and eFeature.oclAsType(EReference).isBackReference() )->notEmpty()]
template <typename T>
bool is_uninitialized(std::weak_ptr<T> const& weak) {
    using wt = std::weak_ptr<T>;
    return !weak.owner_before(wt{}) && !wt{}.owner_before(weak);
}

[/if]
bool [aClass.getImplementationName()/]::eIsSet(int featureID) const
{
    switch(featureID)
    {
    [for (anStructFeature : EStructuralFeature | aClass.getEIsSetFeatures()->sortedBy(name))]
        case [anStructFeature.getMetaModelPackageNameForEStructuralFeature(aClass)/]::[anStructFeature.eContainingClass.getFeatureIDName(anStructFeature)/]:
            return [anStructFeature.generateComparison()/];
    [/for]
    }
    return [removeNamespace(aClass.getClassExtends())/]::eIsSet(featureID);
}
[/template]


[template public generateSetImplementation(aClass : EClass) ? (aClass.getESetFeatures()->notEmpty()) post (trim())]
void [aClass.getImplementationName()/]::eSet(int featureID, const boost::any& newValue)
{
    switch(featureID)
    {
[for (anStructFeature : EStructuralFeature | aClass.getESetFeatures()->sortedBy(name))]
        case [anStructFeature.getMetaModelPackageNameForEStructuralFeature(aClass)/]::[anStructFeature.eContainingClass.getFeatureIDName(anStructFeature)/]:
        {
            [anStructFeature.eGenericType.generateCppType()/] [anStructFeature.name.first(1)/] = boost::any_cast<[anStructFeature.eGenericType.generateCppType()/]>(newValue);
            [anStructFeature.getSetterName()/]([anStructFeature.name.first(1)/]);
            return;
        }
[/for]
    }
    return [removeNamespace(aClass.getClassExtends())/]::eSet(featureID, newValue);
}
[/template]

[template public generateUnSetImplementation(aClass : EClass) ? (aClass.getEUnSetFeatures()->notEmpty())]
[let className : String = aClass.getImplementationName()]
void [className/]::eUnSet(int featureID)
{
    // [protected (className + '::eUnset')]
    std::cout << BOOST_CURRENT_FUNCTION  << std::endl;
    throw "NotImplementedException";
    // [/protected]
}
[/let]
[/template]

[template public generateInvokeImplementation(aClass : EClass) ? (aClass.eOperations->notEmpty()) ]
[let className : String = aClass.getImplementationName()]
boost::any [className/]::eInvoke(int operationID, const std::shared_ptr<EList<boost::any>>& arguments)
{
    // [protected ( className + '::eInvoke')]
    switch( operationID )
    {
    [for ( eOperation : EOperation | aClass.eOperations->sortedBy(name) )]
        case [eOperation.getMetaModelPackageNameForOperation(aClass)/]::[eOperation.eContainingClass.getOperationIDName(eOperation)/]:
        {
            [if eOperation.isVoid() ]
            [eOperation.generateOperationInvoke()/]
            return boost::any();
            [else]
            return [eOperation.generateOperationInvoke()/] 
            [/if]
        }
    [/for]
    }
    return boost::any();
    // [/protected]
}
[/let]
[/template]

[template private generateOperationInvoke(eOperation : EOperation )]
[if eOperation.getVisibilityType(true) = 'no' and eOperation.eContainingClass.name = 'EObject']BasicEObject::[/if][eOperation.name/]([for (eParameter : EParameter | eOperation.eParameters) separator (',')][let needCast : Boolean = not(not eParameter.oclIsUndefined() and eParameter.upperBound = 1 and not eParameter.eGenericType.oclIsUndefined() and eParameter.eGenericType.eClassifier.isAny())][if needCast]boost::any_cast<[eParameter.generateReturnType()/]>([/if]arguments->get([i-1/])[if needCast])[/if][/let][/for]);
[/template]

[template public generateComparison(anStructFeature : EStructuralFeature) ? (oclIsKindOf(EAttribute) and not eType.isAny()) post (trim())]
[if (anStructFeature.upperBound <> 1)]
[anStructFeature.name/]_ && ![anStructFeature.name/]_->empty()
[elseif (eType.oclIsKindOf(EEnum))]
[anStructFeature.name/]_ ![anStructFeature.oclAsType(EAttribute).generateDefaultValue()/];
[else]
[anStructFeature.name/]_ != [anStructFeature.oclAsType(EAttribute).getDefaultValue()/]
[/if]
[/template]

[template public generateComparison(anStructFeature : EStructuralFeature) ? (oclIsKindOf(EReference) and not eType.isAny()) post (trim())]
[if (anStructFeature.upperBound <> 1)]
[anStructFeature.name/]_ && ![anStructFeature.name/]_->empty()
[elseif anStructFeature.oclAsType(EReference).isBackReference() ]
!is_uninitialized([anStructFeature.name/]_)
[else]
[anStructFeature.name/]_ != [anStructFeature.eType.getDefaultValue()/]
[/if]
[/template]

[template public generateComparison(anStructFeature : EStructuralFeature) ? (eType.isAny()) post (trim())]
![anStructFeature.getGetterName()/]().empty()
[/template]

[template public generateStaticFeatureID(anStructFeature : EStructuralFeature,anEClass : EClass )]
/**
 * The feature id for the [anEClass.name/] '[anStructFeature.name.toUpperFirst()/]' [anStructFeature.getFeatureKind()/].
 */
static const int [anEClass.getFeatureIDName(anStructFeature)/] = [anEClass.getFeatureValue(anStructFeature)/];

[/template]

[template public generateStaticFeatureCountID(anEClass : EClass )]
/**
 * The number of structural features of the class [anEClass.name/].
 */
static const int [anEClass.getFeatureCountID()/] = [anEClass.getFeatureCountValue()/];

[/template]


[template public generateInverseAddImplementation(aClass : EClass) ? (aClass.getEInverseAddFeatures()->notEmpty()) ]
[let className : String = aClass.getImplementationName()]
std::shared_ptr<ENotificationChain> [className/]::eBasicInverseAdd( const std::shared_ptr<EObject>& otherEnd, int featureID, const std::shared_ptr<ENotificationChain>& notifications )
{
    // [protected (className + '::eBasicInverseAdd')]
    switch( featureID )
    {
[for ( eFeature : EStructuralFeature | aClass.getEInverseAddFeatures()->sortedBy(name) )]
    [let featureID : String = eFeature.getMetaModelPackageNameForEStructuralFeature(aClass).concat('::').concat(eFeature.eContainingClass.getFeatureIDName(eFeature))]
        case [featureID/]:
        {
        [if eFeature.upperBound <> 1]
            auto list = std::dynamic_pointer_cast<NotifyingEList<std::shared_ptr<EObject>>>( [eFeature.getGetterName()/]() );
            _ASSERTE(list);
            return list->add( otherEnd , notifications );
        [elseif eFeature.isContainer()]
            auto msgs = notifications;
            if (eContainer())
                msgs = eBasicRemoveFromContainer(msgs);
            return eBasicSetContainer( otherEnd , [featureID/], msgs );
        [else]
            break;
        [/if]
    [/let]
        }
[/for]
    }
    return [removeNamespace(aClass.getClassExtends())/]::eBasicInverseAdd(otherEnd, featureID, notifications);
    // [/protected]
}
[/let]
[/template]

[template public generateInverseRemoveImplementation(aClass : EClass) ? (aClass.getEInverseRemoveFeatures()->notEmpty()) ]
[let className : String = aClass.getImplementationName()]
std::shared_ptr<ENotificationChain> [className/]::eBasicInverseRemove( const std::shared_ptr<EObject>& otherEnd, int featureID, const std::shared_ptr<ENotificationChain>& notifications )
{
    // [protected (className + '::eBasicInverseRemove')]
    switch( featureID )
    {
[for ( eFeature : EStructuralFeature | aClass.getEInverseRemoveFeatures()->sortedBy(name) )]
    [let featureID : String = eFeature.getMetaModelPackageNameForEStructuralFeature(aClass).concat('::').concat(eFeature.eContainingClass.getFeatureIDName(eFeature))]
        case [featureID/]:
        {
        [if eFeature.upperBound <> 1]
            auto list = std::dynamic_pointer_cast<NotifyingEList<std::shared_ptr<EObject>>>( [eFeature.getGetterName()/]() );
            _ASSERTE(list);
            return list->remove( otherEnd , notifications );
        [elseif eFeature.isContainer()]
            return eBasicSetContainer( nullptr , [featureID/], notifications );
        [else]
            break;
        [/if]
    [/let]
        }
[/for]
    }
    return [removeNamespace(aClass.getClassExtends())/]::eBasicInverseRemove(otherEnd, featureID, notifications);
    // [/protected]
}
[/let]
[/template]

[template public generateBasicGetDeclaration(aStructuralFeature : EStructuralFeature) ? (isBasicGet())]
[let className : String = aStructuralFeature.eContainingClass.getImplementationName()]
[let methodName : String = aStructuralFeature.getGetterName().toUpperFirst()]
[aStructuralFeature.generateReturnType()/] [className/]::basic[methodName/]() const; 
[/let]
[/let]
[/template]

[template public generateBasicGetDefinition(aStructuralFeature : EStructuralFeature) ? (isBasicGet())]
[let className : String = aStructuralFeature.eContainingClass.getImplementationName()]
[let methodName : String = 'basic' + aStructuralFeature.getGetterName().toUpperFirst()]
[aStructuralFeature.generateReturnType()/] [className/]::[methodName/]() const 
{
    // [protected (className + '::' + methodName)]
[if isContainer()]
    if ( eContainerFeatureID() != [aStructuralFeature.eContainingClass.getFeatureIDName(aStructuralFeature)/] )
        return [aStructuralFeature.generateReturnType()/]();
    else
        return eContainer();
[elseif not isVolatile()]
    return [aStructuralFeature.name/]_;
[elseif (hasKey('getterBody'))]
    [valueKey('getterBody')/]
[else]
    std::cout << BOOST_CURRENT_FUNCTION  << std::endl;
    throw "NotImplementedException";    
[/if]
    // [/protected]
}
[/let]
[/let]
[/template]

[template public generateGetDeclaration(aStructuralFeature : EStructuralFeature, impl : EBoolean) ? (hasGetter('public',impl)) ]
virtual [aStructuralFeature.generateReturnType()/] [aStructuralFeature.getGetterName()/]() const [abstractSufix(impl)/];
    
[/template]

[template public generateGetDefinition(aStructuralFeature : EStructuralFeature) ? (hasGetter('public',true)) ]
[let className : String = aStructuralFeature.eContainingClass.getImplementationName()]
[aStructuralFeature.generateReturnType()/] [className/]::[aStructuralFeature.getGetterName()/]() const 
{
    // [protected (className + '::' + aStructuralFeature.getGetterName()) ]
[if not isVolatile() ]
    [if isListType() ]
    if ( ![aStructuralFeature.name/]_ )
        const_cast<[className/]*>(this)->[aStructuralFeature.name/]_.reset(new [getListConstructor()/]);
    return [aStructuralFeature.name/]_;
    [elseif isContainer()]
    if ( eContainerFeatureID() != [aStructuralFeature.eContainingClass.getFeatureIDName(aStructuralFeature)/] )
        return [aStructuralFeature.generateReturnType()/]();
    else
        return eContainer();
    [elseif isResolveProxies()]
    // TO BE DONE
    std::cout << BOOST_CURRENT_FUNCTION  << std::endl;
    throw "NotImplementedException";
    [else]
    return [aStructuralFeature.name/]_;
    [/if]
[elseif hasKey('getterBody')]
    [valueKey('getterBody')/]
[else]
    std::cout << BOOST_CURRENT_FUNCTION  << std::endl;
    throw "NotImplementedException";
[/if]
    // [/protected]
}
[/let]
[/template]

[template public generateBasicSetDeclaration(aStructuralFeature : EStructuralFeature) ? (isBasicSet())]
[let className : String = aStructuralFeature.eContainingClass.getImplementationName()]
[let methodName : String = 'basic' +aStructuralFeature.getSetterName().toUpperFirst()]
std::shared_ptr<ecore::ENotificationChain> [className/]::[methodName/]() const; 
[/let]
[/let]    
[/template]


[template public generateBasicSetDefinition(aStructuralFeature : EStructuralFeature) ? (isBasicSet())]
[let className : String = aStructuralFeature.eContainingClass.getImplementationName()]
[let methodName : String = 'basic' +aStructuralFeature.getSetterName().toUpperFirst()]
[let varName : String = 'new' + aStructuralFeature.getSafeName().toUpperFirst()]
[aStructuralFeature.generateReturnType()/] [className/]::[methodName/]( [aStructuralFeature.generateParameterType()/] [varName/] , const std::shared_ptr<ecore:ENotificationChain>& msgs) 
{
    // [protected (className + '::' + methodName)]
[if isContainer()]
    return eBasicSetContainer([varName/],msgs); 
[elseif not isVolatile()]
    [let oldVarName : String = 'old' + aStructuralFeature.getSafeName().toUpperFirst()]
    auto [oldVarName/] = [varName/];
    [aStructuralFeature.getSafeName()/]_ = [varName/];
    auto notifications = msgs;
    if ( eNotificationRequired() )
    {
        auto notification = std::make_shared<Notification>( Notification::SET , getThisPtr() ,[aStructuralFeature.eContainingClass.getFeatureIDName(aStructuralFeature)/], [oldVarName/], [varName/] );
        if (notifications)
            notifications->add( notification );
        else
            notifications = notification;
    }
    return notifications;
    [/let]
[elseif (hasKey('setterBody'))]
    [valueKey('setterBody')/]
[else]
    std::cout << BOOST_CURRENT_FUNCTION  << std::endl;
    throw "NotImplementedException";    
[/if]
    // [/protected]
}
[/let]
[/let]
[/let]
[/template]

[template public generateSetDeclaration(aStructuralFeature : EStructuralFeature, impl : EBoolean) ? (hasSetter('public',impl))]
virtual void [aStructuralFeature.getSetterName()/]([aStructuralFeature.generateParameterType()/] [aStructuralFeature.getSafeName()/]) [abstractSufix(impl)/];
[/template]

[template public generateSetDefinition(aStructuralFeature : EStructuralFeature) ? (hasSetter('public',true))]
[let className : String = aStructuralFeature.eContainingClass.getImplementationName()]
[let methodName : String = aStructuralFeature.getSetterName()]
[let varName : String = 'new' + aStructuralFeature.getSafeName().toUpperFirst()]
void [className/]::[methodName/]([aStructuralFeature.generateParameterType()/] [varName/])
{
    // [protected (className + '::' + methodName)]
[if not isVolatile()]
    [if isContainer()]
    if ( [varName/] != eContainer() || (eContainerFeatureID() !=  [aStructuralFeature.eContainingClass.getFeatureIDName(aStructuralFeature)/])) 
    {
        std::shared_ptr<ENotificationChain> notifications;
        if ( eContainer() )
            notifications = eBasicRemoveFromContainer(notifications);
        if ( [varName/] )
            notifications = [varName/]->eInverseAdd( getThisPtr() , [aStructuralFeature.eContainingClass.getFeatureIDName(aStructuralFeature)/], notifications );
        notifications = basic[methodName.toUpperFirst()/]( [varName/], notifications );
        if ( notifications )
            notifications->dispatch();
    }
    else if ( eNotificationRequired() )
        eNotifity( std::make_shared<Notification>(Notification::SET , getThisPtr() ,[aStructuralFeature.eContainingClass.getFeatureIDName(aStructuralFeature)/], [varName/], [varName/]));    
    [elseif isBidirectional() or isContains()]
    if ( [varName/] != [aStructuralFeature.getSafeName()/]_ )
    {
        std::shared_ptr<ENotificationChain> notifications;
        if ( [aStructuralFeature.getSafeName()/]_ )
        [if not isBidirectional()]
            notifications = [aStructuralFeature.getSafeName()/]_->eInverseRemove( getThisPtr(), EOPPOSITE_FEATURE_BASE - [aStructuralFeature.eContainingClass.getFeatureIDName(aStructuralFeature)/] , notifications );
        if ( [varName/] )
            notifications = [varName/]->eInverseAdd( getThisPtr(), EOPPOSITE_FEATURE_BASE - [aStructuralFeature.eContainingClass.getFeatureIDName(aStructuralFeature)/] , notifications );
        [else]
            [let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
            notifications = [aStructuralFeature.getSafeName()/]_->eInverseRemove( getThisPtr(), EOPPOSITE_FEATURE_BASE - [reverseFeature.eContainingClass.getFeatureIDName(reverseFeature)/] , notifications );
        if ( [varName/] )
            notifications = [varName/]->eInverseAdd( getThisPtr(), EOPPOSITE_FEATURE_BASE - [reverseFeature.eContainingClass.getFeatureIDName(reverseFeature)/] , notifications );
            [/let]
        [/if]
        notifications = basic[aStructuralFeature.getSetterName().toUpperFirst()/]([varName/],notifications);
        if (notifications)
            notifications->dispatch();
    }
        [if isUnSettable()]
        [/if]
    [else]
        [let oldVarName : String = 'old' + aStructuralFeature.getSafeName().toUpperFirst()]
    auto [oldVarName/] = [aStructuralFeature.getSafeName()/]_;
    [aStructuralFeature.getSafeName()/]_ = [varName/]_;
    if ( eNotificationRequired() )
        eNotifity( std::make_shared<Notification>(Notification::SET , getThisPtr() ,[aStructuralFeature.eContainingClass.getFeatureIDName(aStructuralFeature)/], [oldVarName/], [varName/]));
        [/let]
    [/if]
[elseif hasKey('setterBody')]
    [valueKey('setterBody')/] 
[else]
    std::cout << BOOST_CURRENT_FUNCTION  << std::endl;
    throw "NotImplementedException";    
[/if]
    // [/protected]
}
[/let]
[/let]
[/let]
[/template]


[template private getListConstructor( anEAttribute : EStructuralFeature ) post(trim())]
[/template]

[template private getListConstructor( anEAttribute : EAttribute ) post(trim())]
BasicEList<[anEAttribute.eGenericType.generateCppType()/],[anEAttribute.unique/]>()
[/template]

[template private getListConstructor( anEReference : EReference ) post(trim())]
[let typeArgument : String = anEReference.eGenericType.generateCppType()]
[let thisPtrGetterName : String = anEReference.eContainingClass.generateGetThisPtrPropertyGetterName()]
[let packageName : String = anEReference.getMetaModelPackageNameForEStructuralFeature(anEReference.eContainingClass)]
[let featureID : String = anEReference.eContainingClass.getFeatureIDName( anEReference )]
[if (anEReference.containment)]
    [if anEReference.eOpposite.oclIsUndefined() ]
        EObjectEList<[typeArgument/],true,true,false>([thisPtrGetterName/](), [packageName/]::[featureID/] )
    [else]
        [let reverseFeature :EReference = anEReference.eOpposite ]
        [let reversePackageName : String = reverseFeature.getMetaModelPackageNameForEStructuralFeature(reverseFeature.eContainingClass) ]
        [let reverseFeatureID :String = reverseFeature.eContainingClass.getFeatureIDName(reverseFeature) ]
        EObjectEList<[typeArgument/],true,true,true>( [thisPtrGetterName/](), [packageName/]::[featureID/] , [reversePackageName/]::[reverseFeatureID/])
        [/let]
        [/let]
        [/let]
    [/if]
[else]
    [if anEReference.eOpposite.oclIsUndefined() ]
        EObjectEList<[typeArgument/],false,false,false>( [thisPtrGetterName/](), [packageName/]::[featureID/])
    [else]
        [let reverseFeature :EReference = anEReference.eOpposite ]
        [let reversePackageName : String = reverseFeature.getMetaModelPackageNameForEStructuralFeature(reverseFeature.eContainingClass) ]
        [let reverseFeatureID :String = reverseFeature.eContainingClass.getFeatureIDName(reverseFeature) ]
        EObjectEList<[typeArgument/],false,true,true>( [thisPtrGetterName/](), [packageName/]::[featureID/] , [reversePackageName/]::[reverseFeatureID/])
        [/let]
        [/let]
        [/let]
    [/if]
[/if]
[/let]
[/let]
[/let]
[/let]
[/template]
