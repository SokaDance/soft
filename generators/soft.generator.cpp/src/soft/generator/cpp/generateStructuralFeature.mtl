[comment encoding = UTF-8 /]
[module generateStructuralFeature('http://www.eclipse.org/emf/2002/Ecore')]

[import soft::generator::cpp::utils /]
[import soft::generator::cpp::generateAttribute /]
[import soft::generator::cpp::generateType /]
[import soft::generator::cpp::generateReference /]

[**
 * eGet Function
*/]
[template public generateGetDeclaration(aClass : EClass,impl : Boolean) ? (aClass.eStructuralFeatures->notEmpty()) post (trim())]
virtual boost::any eGet(int featureID, bool resolve, bool coreType) const [abstractSufix(impl)/];
[/template]

[template public generateIsSetDeclaration(aClass : EClass,impl : Boolean) ? (aClass.eStructuralFeatures->notEmpty()) post (trim())]
virtual bool eIsSet(int featureID) const [abstractSufix(impl)/];
[/template]

[template public generateSetDeclaration(aClass : EClass,impl : Boolean) ? (aClass.eStructuralFeatures->notEmpty()) post (trim())]
virtual void eSet(int featureID, const boost::any& newValue) [abstractSufix(impl)/];
[/template]

[template public generateUnSetDeclaration(aClass : EClass,impl : Boolean)]
virtual void eUnSet(int featureID) [abstractSufix(impl)/];
[/template]

[template public generateInvokeDeclaration(aClass : EClass,impl : Boolean)]
virtual boost::any eInvoke( int operationID, const std::shared_ptr<EList<boost::any>>& arguments )[abstractSufix(impl)/];
[/template]

[template public generateGetImplementation(aClass : EClass) ? (aClass.eStructuralFeatures->notEmpty()) post (trim())]
boost::any [aClass.name.toUpperFirst().concat('Impl')/]::eGet(int featureID, bool resolve, bool coreType) const
{
    switch(featureID)
    {
    [for (anStructFeature : EStructuralFeature | aClass.eStructuralFeatures->asOrderedSet()->sortedBy(name))]
        case [anStructFeature.getMetaModelPackageNameForEStructuralFeature(aClass)/]::[anStructFeature.eContainingClass.getFeatureIDName(anStructFeature)/]:
            return [anStructFeature.getGetterName()/]();
    [/for]
    }
[if (aClass.eSuperTypes->isEmpty() and not (aClass.name ='EObject'))]
    return ecore::EObjectImpl::eGet(featureID, resolve, coreType);
[elseif (aClass.eSuperTypes->size() = 1)]
    return [getClassWithNamespace(aClass, aClass.eSuperTypes->first())/]Impl::eGet(featureID, resolve, coreType);
[else]
    boost::any result;
    [let eClasses : OrderedSet(EClass) = aClass.eSuperTypes->asOrderedSet()->sortedBy(name)]
    [for (sClass : EClass | eClasses)]
    result = [getClassWithNamespace(aClass,sClass)/]Impl::eGet(featureID, resolve, coreType);
    [if (sClass <> eClasses->last())]
    if (!result->isEmpty())
        return result;
    [/if]
    [/for]
    return result;
    [/let]
[/if]
}
[/template]

[template public generateIsSetImplementation(aClass : EClass) ? (aClass.eStructuralFeatures->notEmpty()) post (trim())]
bool [aClass.name.toUpperFirst().concat('Impl')/]::eIsSet(int featureID) const
{
    switch(featureID)
    {
    [for (anStructFeature : EStructuralFeature | aClass.eStructuralFeatures->asOrderedSet()->sortedBy(name))]
        case [anStructFeature.getMetaModelPackageNameForEStructuralFeature(aClass)/]::[anStructFeature.eContainingClass.getFeatureIDName(anStructFeature)/]:
            return [anStructFeature.generateComparison()/];
    [/for]
    }
[if (aClass.eSuperTypes->isEmpty() and not (aClass.name ='EObject'))]
    return ecore::EObjectImpl::eIsSet(featureID);
[elseif (aClass.eSuperTypes->size() = 1)]
    return [getClassWithNamespace(aClass, aClass.eSuperTypes->first())/]Impl::eIsSet(featureID);
[else]
    bool result = false;
    [let eClasses : OrderedSet(EClass) = aClass.eSuperTypes->asOrderedSet()->sortedBy(name)]        
    [for (sClass : EClass | eClasses)]
    result = [getClassWithNamespace(aClass,sClass)/]Impl::eIsSet(featureID);
    [if (sClass <> eClasses->last())]
    if (result)
        return result;
    [/if]
    [/for]
    return result;
    [/let]
[/if]
}
[/template]


[template public generateSetImplementation(aClass : EClass) ? (aClass.eStructuralFeatures->select(hasSetter())->notEmpty()) post (trim())]
void [aClass.name.toUpperFirst().concat('Impl')/]::eSet(int featureID, const boost::any& newValue)
{
    switch(featureID)
    {
[for (anStructFeature : EStructuralFeature | aClass.eStructuralFeatures->select(hasSetter())->asOrderedSet()->sortedBy(name))]
        case [anStructFeature.getMetaModelPackageNameForEStructuralFeature(aClass)/]::[anStructFeature.eContainingClass.getFeatureIDName(anStructFeature)/]:
        {
            [anStructFeature.eGenericType.generateCppType()/] [anStructFeature.name.first(1)/] = boost::any_cast<[anStructFeature.eGenericType.generateCppType()/]>(newValue);
            [anStructFeature.getSetterName()/]([anStructFeature.name.first(1)/]);
            return;
        }
[/for]
    }
[if (aClass.eSuperTypes->isEmpty() and not (aClass.name ='EObject'))]
    ecore::EObjectImpl::eSet(featureID, newValue);
[elseif (aClass.eSuperTypes->size() = 1)]
    [getClassWithNamespace(aClass, aClass.eSuperTypes->first())/]Impl::eSet(featureID, newValue);
[else]
    [let eClasses : OrderedSet(EClass) = aClass.eSuperTypes->asOrderedSet()->sortedBy(name)]
    [for (sClass : EClass | eClasses)]
    [getClassWithNamespace(aClass,sClass)/]Impl::eSet(featureID, newValue);
    [/for]
    [/let]
[/if]
}
[/template]

[template public generateUnSetImplementation(aClass : EClass)]
void [aClass.name.toUpperFirst().concat('Impl')/]::eUnSet(int featureID)
{
    // [protected (aClass.name.concat('Impl::eUnset'))]
    std::cout << BOOST_CURRENT_FUNCTION  << std::endl;
    throw "NotImplementedException";
    // [/protected]
}
[/template]

[template public generateInvokeImplementation(aClass : EClass)]
boost::any [aClass.name.toUpperFirst().concat('Impl')/]::eInvoke(int featureID, const std::shared_ptr<EList<boost::any>>& arguments)
{
    // [protected (aClass.name.concat('Impl::eInvoke'))]
    std::cout << BOOST_CURRENT_FUNCTION  << std::endl;
    throw "NotImplementedException";
    // [/protected]
}
[/template]

[template public generateComparison(anStructFeature : EStructuralFeature) ? (oclIsKindOf(EAttribute) and not eType.requiresAny()) post (trim())]
[if (anStructFeature.upperBound <> 1)]
![anStructFeature.getGetterName()/]()->empty()
[elseif (eType.oclIsKindOf(EEnum))]
[anStructFeature.name/]_ ![anStructFeature.oclAsType(EAttribute).generateDefaultValue()/];
[else]
[anStructFeature.getGetterName()/]() != [anStructFeature.oclAsType(EAttribute).getDefaultValue()/]
[/if]
[/template]

[template public generateComparison(anStructFeature : EStructuralFeature) ? (not oclIsKindOf(EAttribute) and not eType.requiresAny())]
[anStructFeature.getGetterName()/]() != [anStructFeature.eType.getDefaultValue()/]
[/template]

[template public generateComparison(anStructFeature : EStructuralFeature) ? (eType.requiresAny())]
![anStructFeature.getGetterName()/]().empty()
[/template]

[template public generateStaticFeatureID(anStructFeature : EStructuralFeature,anEClass : EClass )]
/**
 * The feature id for the [anEClass.name/] '[anStructFeature.name.toUpperFirst()/]' [anStructFeature.getFeatureKind()/].
 */
static const int [anEClass.getFeatureIDName(anStructFeature)/] = [anEClass.getFeatureValue(anStructFeature)/];

[/template]

[template public generateStaticFeatureCountID(anEClass : EClass )]
/**
 * The number of structural features of the class [anEClass.name/].
 */
static const int [anEClass.getFeatureCountID()/] = [anEClass.getFeatureCountValue()/];

[/template]
