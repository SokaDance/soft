[comment encoding = UTF-8 /]
[module generateCommon('http://www.eclipse.org/emf/2002/Ecore')/]


[query public join( aSequence : Sequence(String) , aDelimiter : String ) : String = 
    aSequence->iterate(s ; res: String ='' | ( res.concat( if ( aSequence->first() = s ) then '' else aDelimiter endif ).concat(s)))
/]

[query public format( aString : String , aArguments : Sequence(String) ) : String =
    Sequence{1..aArguments->size()}->iterate(index ; res: String =aString | res.replace('\\{'+ (index - 1) + '\\}', aArguments->at(index)))
/]

[query public matches( aString : String , aRegExp : String ) : Boolean =
    aString.replaceAll(aRegExp, '') <> aString
/]


[**
 * Helper for c++ abstract function sufix
*/]
[query public abstractSufix(impl : Boolean) : String = if (impl = false) then '= 0' else '' endif/]
[query public getterPrefix(feature : EStructuralFeature) : String = if feature.eType.name = 'EBoolean' then 'is' else 'get' endif/]

[query public getSetterName(feature : EStructuralFeature) : String = if hasKey('SetterName') then valueKey('SetterName') else 'set'.concat(name.toUpperFirst()) endif/]
[query public getGetterName(feature : EStructuralFeature) : String = if hasKey('GetterName') then valueKey('GetterName') else getterPrefix().concat(name.toUpperFirst()) endif/]
[query public getUnSetterName(feature : EStructuralFeature) : String = if hasKey('UnSetterName') then valueKey('UnSetterName') else 'unset'.concat(name.toUpperFirst()) endif/]
[query public getIsSetName(feature : EStructuralFeature) : String = if hasKey('IsSetName') then valueKey('IsSetName') else 'isSet'.concat(name.toUpperFirst()) endif/]
[query public getLazyInitializationName(feature : EStructuralFeature) : String = if hasKey('LazyInitializationName') then valueKey('LazyInitializationName') else 'init'.concat(name.toUpperFirst()) endif/]



[**
 * File Comments 
*/]
[template public fileComment(aAny : OclAny)]
// *****************************************************************************
//
// This file is part of a MASA library or program.
// Refer to the included end-user license agreement for restrictions.
//
// Copyright (c) 2018 MASA Group
//
// *****************************************************************************

// *****************************************************************************
//    
// Warning: This file was generated by soft.generator.cpp Generator
// 
//*****************************************************************************
[/template]


[**
 * Guards
*/]
[query private getGuardName(namedelement : ENamedElement, sufix: String) : String = 
        if (namedelement.eContainer().oclIsUndefined()) 
        then namedelement.name.concat(sufix).concat('_hpp').toUpperCase() 
        else namedelement.eContainer().oclAsType(EPackage).name.concat('_').concat(namedelement.name).concat(sufix).concat('_hpp').toUpperCase()
        endif/]

[template public startGuard(namedelement : ENamedElement)]
[startGuard(namedelement,'')/]
[/template]

[template public startGuard(namedelement : ENamedElement, sufix : String)]
#ifndef [getGuardName(sufix)/]
#define [getGuardName(sufix)/]
[/template]


[template public endGuard(namedelement : ENamedElement)]
[endGuard(namedelement, '')/]
[/template]

[template public endGuard(namedelement : ENamedElement, sufix : String)]
#endif /* [getGuardName(sufix)/] */
[/template]

[**
 * Namespaces
*/]
[query public getInterfaceNamespaceName( aPackage : EPackage ) : String = aPackage.getQualifiedNamespaceName( aPackage.getInterfaceNamespace() ) /]
[query public getImplementationNamespaceName( aPackage : EPackage ) : String = aPackage.getQualifiedNamespaceName( aPackage.getImplementationNamespace() )/]
[query public getTestsNamespaceName( aPackage : EPackage ) : String = aPackage.getQualifiedNamespaceName( aPackage.getTestsNamespace() )/]
[query public getExtensionNamespaceName( aPackage : EPackage ) : String = aPackage.getQualifiedNamespaceName( aPackage.getExtensionNamespace() )/]

[query private getBaseNamespace( aPackage : EPackage ) : String = if hasKey('baseNamespace') then valueKey('baseNamespace') else '' endif/]
[query private getInterfaceNamespace( aPackage : EPackage ) : String = if hasKey('interfaceNamespace') then valueKey('interfaceNamespace') else '' endif/]
[query private getImplementationNamespace( aPackage : EPackage ) : String = if hasKey('implementationNamespace') then valueKey('implementationNamespace') else 'impl' endif/]
[query private getExtensionNamespace( aPackage : EPackage ) : String = if hasKey('extensionNamespace') then valueKey('extensionNamespace') else 'ext' endif/]
[query private getTestsNamespace( aPackage : EPackage ) : String = if hasKey('testsNamespace') then valueKey('testsNamespace') else 'tests' endif/]
[query private getQualifiedNamespaceName( aPackage : EPackage , aSuffix : String  ) : String = 
    if ( matches(aSuffix,'\\{\\d+\\}') ) then
        addNamespacePrefix(aPackage.getBaseNamespace(),aSuffix.format(aPackage.getNamespaceNameSubstitutions()))
    else 
        addNamespaceSuffix(aPackage.getQualifiedNamespaceName(),aSuffix) endif
/]
[query private getQualifiedNamespaceName( aPackage : EPackage ) : String = addNamespacePrefix( aPackage.getBaseNamespace() , aPackage.name )/]
[query private addNamespacePrefix( aPrefix : String , aName : String ) : String = if ( aPrefix = '' ) then aName else aPrefix + '::' + aName endif/]
[query private addNamespaceSuffix( aName : String , aSuffix : String ) : String = if ( aSuffix = '' ) then aName else aName + '::' + aSuffix endif/]
[query private getNamespaceNameSubstitutions( aPackage : EPackage ) : Sequence(String) =
   let names : Sequence(String) = aPackage.getNamespaceNames() in
    if ( names->size() > 1 ) then
        names->prepend( join( names , '::' ) )
    else
        names
    endif
/]
[query private getNamespaceNames( aPackage : EPackage ) : Sequence(String) =
    if ( aPackage.oclIsUndefined() ) then
        Sequence(String){}
    else
        aPackage.eSuperPackage.getNamespaceNames()->append( aPackage.name )
    endif
/]

[query public getShortQualifiedName( aQualifiedName : String , aNamespaceName : String ) : String =
    let aQualifiedNames : Sequence(String) = aQualifiedName.tokenize('::') in
    let aNamespaceNames : Sequence(String) = aNamespaceName.tokenize('::') in
    let shortQualifiedNames : Sequence(String) = Sequence{1..aQualifiedNames->size()}->iterate( index ; res : Sequence(String) = Sequence{} |
        let n : String = aQualifiedNames->at(index) in
        if ( res->isEmpty() and index <= aNamespaceNames->size() and (n = aNamespaceNames->at(index)) ) then
            res
        else
            res->append(n)
        endif
    ) in
    shortQualifiedNames->join('::')
/]

[query public removeNamespace( aQualifiedName : String ) : String = 
    let index : Integer = aQualifiedName.lastIndexOf( '::') in
    if ( index = -1 ) then
        aQualifiedName
    else
        aQualifiedName.substring( index + 2)
    endif
/]
[**
 * Output folders
*/]
[query public namespaceToFolder( aQualified : String  ) : String = aQualified.substituteAll('::', '/')/]
[query public getImplementationFolder( aPackage : EPackage ) : String = namespaceToFolder(aPackage.getImplementationNamespaceName())/]
[query public getInterfaceFolder( aPackage : EPackage ) : String = namespaceToFolder(aPackage.getInterfaceNamespaceName())/]
[query public getTestsFolder( aPackage : EPackage ) : String = namespaceToFolder(aPackage.getTestsNamespaceName())/]

[**
 * Classes names
*/]
[query public getInterfaceName( aClass : EClass ) : String = getInterfaceName(aClass.name,aClass.ePackage) /]
[query public getInterfaceName( aPackage : EPackage ) : String = getInterfaceName( getPackageName(),aPackage) /]
[query private getInterfaceName( aElementName : String , aPackage : EPackage ) : String = let pattern : String = aPackage.getInterfaceNamePattern() in if pattern ='' then aElementName else pattern.format(Sequence{aElementName}) endif /]
[query private getInterfaceNamePattern( aPackage : EPackage ) : String = if hasKey('interfaceNamePattern') then valueKey('interfaceNamePattern') else '' endif/]

[query public getImplementationName( aClass : EClass ) : String = getImplementationName(aClass.name, aClass.ePackage)/]
[query public getImplementationName( aPackage : EPackage ) : String = getImplementationName( getPackageName(),aPackage)/]
[query private getImplementationName( aElementName : String , aPackage : EPackage ) : String = let pattern : String = aPackage.getImplementationNamePattern() in if pattern ='' then aElementName + 'Impl' else pattern.format(Sequence{aElementName}) endif /]
[query private getImplementationNamePattern( aPackage : EPackage ) : String = if hasKey('implementationNamePattern') then valueKey('implementationNamePattern') else '' endif/]

[query public getExtensionName( aClass : EClass ) : String = getExtensionName(aClass.name, aClass.ePackage)/]
[query public getExtensionName( aPackage : EPackage ) : String = getExtensionName( getPackageName(),aPackage)/]
[query private getExtensionName( aElementName : String , aPackage : EPackage ) : String = let pattern : String = aPackage.getExtensionNamePattern() in if pattern ='' then aElementName + 'Ext' else pattern.format(Sequence{aElementName}) endif /]
[query private getExtensionNamePattern( aPackage : EPackage ) : String = if hasKey('extensionNamePattern') then valueKey('extensionNamePattern') else '' endif/]

[query public getMockName( aClass : EClass ) : String = getMockName(aClass.name, aClass.ePackage)/]
[query private getMockName( aElementName : String , aPackage : EPackage ) : String = 
    let name : String = if aElementName.first(1) = 'I' or aElementName.first(1) = 'E' then aElementName.substring(2) else aElementName endif in
    let pattern : String = aPackage.getMockNamePattern() in 
    if pattern ='' then 'Mock' + name else pattern.format(Sequence{name}) endif 
/]
[query private getMockNamePattern( aPackage : EPackage ) : String = if hasKey('mockNamePattern') then valueKey('mockNamePattern') else '' endif/]

[query public getFactoryInterfaceName( aPackage : EPackage ) : String = getInterfaceName( getFactoryName() , aPackage )/]
[query public getFactoryImplementationName( aPackage : EPackage ) : String = getImplementationName( getFactoryName() , aPackage )/]
[query public getFactoryExtensionName( aPackage : EPackage ) : String = getExtensionName( getFactoryName() , aPackage )/]

[query private getFactoryName( aPackage : EPackage ) : String = aPackage.name.toUpperFirst() + 'Factory'/]
[query private getPackageName( aPackage : EPackage ) : String = aPackage.name.toUpperFirst() + 'Package'/]

[query public getQualifiedInterfaceName( aClass : EClass ) : String = addNamespacePrefix( aClass.ePackage.getInterfaceNamespaceName() , aClass.getInterfaceName() )/]
[query public getQualifiedInterfaceName( aPackage : EPackage ) : String = addNamespacePrefix( aPackage.getInterfaceNamespaceName() , aPackage.getInterfaceName() )/]

[query public getQualifiedImplementationName( aClass : EClass ) : String = addNamespacePrefix( aClass.ePackage.getImplementationNamespaceName() , aClass.getImplementationName())/]
[query public getQualifiedImplementationName( aPackage : EPackage ) : String = addNamespacePrefix( aPackage.getImplementationNamespaceName() , aPackage.getImplementationName())/]

[query public getQualifiedExtensionName( aClass : EClass ) : String = addNamespacePrefix( aClass.ePackage.getExtensionNamespaceName() , aClass.getExtensionName())/]

[query public getQualifiedMockName( aClass : EClass ) : String = addNamespacePrefix( aClass.ePackage.getTestsNamespaceName() , aClass.getMockName())/]

[query public getFactoryQualifiedInterfaceName( aPackage : EPackage ) : String = addNamespacePrefix( aPackage.getInterfaceNamespaceName() , aPackage.getFactoryInterfaceName() )/]
[query public getFactoryQualifiedImplementationName( aPackage : EPackage ) : String = addNamespacePrefix( aPackage.getImplementationNamespaceName() , aPackage.getFactoryImplementationName() )/]
[query public getFactoryQualifiedExtensionName( aPackage : EPackage ) : String = addNamespacePrefix( aPackage.getExtensionNamespaceName() , aPackage.getFactoryExtensionName() )/]

[query public hasContainerAttribute(aClass : EClass) : Boolean =  getContainerAttribute()->notEmpty() /]
[query public getContainerAttribute(aClass : EClass) : OrderedSet(EReference) =  aClass.eReferences->select(isContainerAttribute())->sortedBy(name) /]
[query public isContainerAttribute(aRef : EReference) : Boolean =  aRef.container/]
[query public isContainer(aStructuralFeature : EStructuralFeature) : Boolean =  
    if aStructuralFeature.oclIsKindOf(EReference) then
        let eReference : EReference = aStructuralFeature.oclAsType(EReference) in
        if eReference.eOpposite.oclIsUndefined() then
            false
        else
            eReference.eOpposite.containment
        endif
    else 
        false 
    endif
/]
[query public isBidirectional(aStructuralFeature : EStructuralFeature) : Boolean = if aStructuralFeature.oclIsKindOf(EReference) then not aStructuralFeature.oclAsType(EReference).eOpposite.oclIsUndefined() else false endif/]
[query public isContains(aStructuralFeature : EStructuralFeature) : Boolean = aStructuralFeature.oclIsKindOf(EReference) and aStructuralFeature.oclAsType(EReference).containment/]
[query public isChangeable(aStructuralFeature : EStructuralFeature) : Boolean = aStructuralFeature.changeable/]
[query public isUnSettable(aStructuralFeature : EStructuralFeature) : Boolean = aStructuralFeature.unsettable and not aStructuralFeature.isContainer() /]
[query public isVolatile(aStructuralFeature : EStructuralFeature) : Boolean = 
    let eReverseFeature : EReference = if aStructuralFeature.oclIsKindOf(EReference) then aStructuralFeature.oclAsType(EReference).eOpposite else null endif in
    aStructuralFeature.volatile or ( not eReverseFeature.oclIsUndefined() and eReverseFeature.volatile )
/]
[query public isListType(aTypedElement : ETypedElement ) : Boolean = (not aTypedElement.oclIsUndefined() ) and ( aTypedElement.many or aTypedElement.upperBound <> 1 )/]  
[query public isProxy(aStructuralFeature : EStructuralFeature) : Boolean = (not isContainer() and not isContains()) and aStructuralFeature.oclIsKindOf(EReference) and aStructuralFeature.oclAsType(EReference).resolveProxies/]  
[query public isField(aStructuralFeature : EStructuralFeature) : Boolean = not isContainer() and not isVolatile()/]

[query public isGet(aStructuralFeature : EStructuralFeature) : Boolean = true/]
[query public isSet(aStructuralFeature : EStructuralFeature) : Boolean = isChangeable() and aStructuralFeature.upperBound = 1/]
[query public isUnSet(aStructuralFeature : EStructuralFeature) : Boolean = isChangeable() and isUnSettable()/]
[query public isIsSet(aStructuralFeature : EStructuralFeature) : Boolean = isUnSettable()/]

[query public isBasicSet(aStructuralFeature : EStructuralFeature) : Boolean = not isListType() and ( isChangeable() or not isContainer() ) and ( isBidirectional() and not isVolatile() or isContains() ) /]
[query public isBasicGet(aStructuralFeature : EStructuralFeature) : Boolean = isProxy() and not isListType()/]
[query public isBasicUnSet(aStructuralFeature : EStructuralFeature) : Boolean = isUnSettable() and isChangeable() and not isListType() and aStructuralFeature.oclIsKindOf(EReference) and ( isBidirectional() or isContains() )/]

[query private getSuperTypeContainers(aClass:EClass) : OrderedSet(EReference) = if not(aClass.eSuperTypes->isEmpty()) then aClass.eSuperTypes.getAllContainers()->flatten()->asOrderedSet() else OrderedSet{} endif /]
[query public getAllContainers(aClass : EClass) : OrderedSet(EReference) =  if getContainerAttribute()->notEmpty() then if getSuperTypeContainers()->isEmpty() then getContainerAttribute() else OrderedSet{getContainerAttribute()}->append(getSuperTypeContainers()->flatten()->reject(oclIsUndefined())->asOrderedSet())->flatten()->asOrderedSet() endif else getSuperTypeContainers()->asOrderedSet() endif /]

[query public hasGenModel(aModelElement : EModelElement) : Boolean = eAnnotations->select( source = 'http://net.masagroup/soft/2018/GenModel' )->notEmpty() /]
[query public getGenModelAnnotation(aModelElement : EModelElement) : EAnnotation = eAnnotations->select( source = 'http://net.masagroup/soft/2018/GenModel' )->first() /]

[query public hasKey(aModelElement : EModelElement, aKey:String) : Boolean = if aModelElement.hasGenModel() then aModelElement.getGenModelAnnotation().details->select(key = aKey)->notEmpty() else false endif /]
[query public valueKey(aModelElement : EModelElement, aKey:String) : String = aModelElement.getGenModelAnnotation().details->select(key = aKey)->first().value /]

[query public ignore(aModelElement : EModelElement) : Boolean = eAnnotations->select(source = 'ignore')->notEmpty()  /]

[template public generateTypesForwardDeclaration(anEClass : EClass)]
[if (anEClass.eReferences->select(upperBound <> 1)->size() > 0 or anEClass.eOperations.eParameters->select((eType.requiresList()  or upperBound <> 1))->size() > 0)]
namespace ecore 
{
    template<typename T> class EList;
}
[/if]
[if anEClass.eOperations->exists( o | o.eGenericType.eClassifier.name ='ETreeIterator')]
namespace ecore 
{
    template<typename T> class ECollectionView;
}
[/if]
[/template]

[template public generateAbstractDataTypesIncludes(anEClass : EClass)]
[if (anEClass.eReferences->select(upperBound <> 1)->size() > 0 or anEClass.eOperations.eParameters->select((eType.requiresList()  or upperBound <> 1))->size() > 0)]
#include "ecore/EList.hpp"
[/if]
[/template]

[query public requiresList(anEClassifier : EClassifier) : Boolean = if (oclIsUndefined()) then false else (name = 'ETreeIterator' or name = 'EEList') endif/]

[query public getPackageName(aStructural : EStructuralFeature,aClass: EClass) : String = if( aStructural.eContainingClass.ePackage = aClass.ePackage  ) then aStructural.eContainingClass.ePackage.getInterfaceName() else aStructural.eContainingClass.ePackage.getQualifiedInterfaceName() endif/]
[query public getPackageName(aOperation : EOperation,aClass: EClass) : String = if( aOperation.eContainingClass.ePackage = aClass.ePackage  ) then aOperation.eContainingClass.ePackage.getInterfaceName() else aOperation.eContainingClass.ePackage.getQualifiedInterfaceName() endif/]


[query private getMemberName(anENamedElement : ENamedElement) : String = 
    if anENamedElement.oclIsKindOf(EClassifier) then 
        anENamedElement.oclAsType(EClassifier).getMemberName() 
    else if anENamedElement.oclIsKindOf(EStructuralFeature) then 
        anENamedElement.oclAsType(EStructuralFeature).getMemberName()
    else if anENamedElement.oclIsKindOf(EOperation) then
        anENamedElement.oclAsType(EOperation).getMemberName()
    else
         anENamedElement.name.toLowerFirst()
    endif endif endif
/]
[query private getMemberName(anEClassifier : EClassifier) : String = anEClassifier.name.toLowerFirst() /]
[query private getMemberName(aStructural : EStructuralFeature) : String = aStructural.eContainingClass.name.toLowerFirst().concat('_').concat(aStructural.name.toUpperFirst()) /]
[query private getMemberName(aOperation : EOperation) : String = aOperation.eContainingClass.name.toLowerFirst().concat('_'.concat(aOperation.name.toUpperFirst()).concat(aOperation.getParameterListName())) /]
[query private getParameterListName( aOperation : EOperation) : String = if aOperation.eParameters->notEmpty() then '_'.concat(aOperation.getParameterListDetailsName()) else '' endif /]
[query private getParameterListDetailsName(aOperation : EOperation) : String = if aOperation.eParameters->size()>1 then aOperation.eParameters->first().eType.name.concat('_').concat(aOperation.eParameters->last().eType.name) else aOperation.eParameters->first().eType.name endif /]


[query public getElementIdentifier(anENamedElement : ENamedElement) : String = anENamedElement.name.concat( if anENamedElement.oclIsKindOf(EOperation) then anENamedElement.oclAsType(EOperation).getParameterListName() else '' endif) /]
[query public getElementAccessorName(anENamedElement : ENamedElement) : String = anENamedElement.getMemberName().toUpperFirst() /]
[query public getElementInstanceName(anENamedElement : ENamedElement) : String = anENamedElement.getMemberName().concat('_') /]
[query public getElementIDAccessorName(anEClass : EClass) : String = 
    if(name = 'EClass' or name = 'EDataType' or name = 'EEnum') then 'Classifier'
    else if(name = 'EAttribute' or name = 'EReference') then 'Feature' 
    else if(name = 'EOperation') then 'Operation'
    else ''
    endif endif endif/]



[query public getMetaType(aClass : EClassifier) : String = getMetaType(aClass, aClass.ePackage) /]
[query public getMetaType(anENamedElement : ENamedElement, anEPackage : EPackage) : String = if anEPackage = anENamedElement.eClass().ePackage then anENamedElement.eClass().getInterfaceName() else anENamedElement.eClass().getQualifiedInterfaceName() endif /]

[query public getPackageGetter(aReference : EReference) : String = if oclIsUndefined() then 'nullptr' else getterPrefix().concat(getElementAccessorName()).concat('()') endif/]
[query public getPackageGetter(aAttribute : EAttribute) : String = 'get'.concat(getElementAccessorName()).concat('()') /]

[query public packageGetter(aEClassifier : EClassifier, aStruct : EStructuralFeature) : String = packageGetter(aEClassifier,aStruct.eContainingClass) /]
[query public packageGetter(aEClass : EClass, supertype : EClass) : String = packageGetter(supertype.oclAsType(EClassifier),aEClass.oclAsType(EClassifier)) /]
[query public packageGetter(aEClassifier1 : EClassifier, aEClassifier2 : EClassifier) : String = needMetaModelPackageGetter(aEClassifier1, aEClassifier2).concat('get').concat(aEClassifier1.getElementAccessorName()).concat('()') /]
[query public needMetaModelPackageGetter(aClassifier1 : EClassifier ,aClassifier2 : EClassifier ) : String = if(aClassifier1.ePackage.name = aClassifier2.ePackage.name )then '' else  aClassifier1.ePackage.nsPrefix.concat('::').concat(aClassifier1.ePackage.name.toUpperFirst()).concat('Package').concat('::eInstance()->')  endif /]

[**
 * GenerateUtils java class methods 
*/]
[query public lowerCamelToUpperUnderscore( eEObject : EObject , s : String ) : String = invoke('soft.generator.cpp.utils.GenerateUtils','lowerCamelToUpperUnderscore(java.lang.String)',Sequence{s}) /]
[query public upperCamelToUpperUnderscore( eEObject : EObject , s : String ) : String = invoke('soft.generator.cpp.utils.GenerateUtils','upperCamelToUpperUnderscore(java.lang.String)',Sequence{s}) /]
[query public splitAndCombineWords( eEObject : EObject , s : String, sep: String) : String = invoke('soft.generator.cpp.utils.GenerateUtils','splitAndCombineWords(java.lang.String,java.lang.String)',Sequence{s,sep}) /]

[**
 * Feature / Operation IDs and Count IDs 
*/]

[query public getClassifierIDName( anEClass : EClassifier ) : String = splitAndCombineWords(anEClass.name,'_').toUpperCase()/]
[query public getClassifierIDName( anEClass : EClass ,anEClassifier : EClassifier) : String = anEClass.getClassifierIDName().concat('__').concat(splitAndCombineWords(anEClassifier.name,'_')).toUpperCase()/]
[query public getClassifierIDValue(anEClassifier : EClassifier) : EInt = if (anEClassifier.getClassifierID() = 0) then anEClassifier.ePackage.eClassifiers->selectByKind(EClassifier)->size() else anEClassifier.getClassifierID() endif/]

[query public getFeatureCountID( aEClass : EClass ) : String = aEClass.getClassifierIDName().concat('_FEATURE_COUNT')/]
[query public getFeatureCountValue( aEClass : EClass ) : String = 
    let baseClass : EClass = aEClass.getBaseClass() in
    if baseClass.oclIsUndefined() then
        aEClass.getFeatureCount()
    else
        let baseCount : String = if baseClass.ePackage = aEClass.ePackage then baseClass.getFeatureCountID() else baseClass.getFeatureCountID() endif in
        baseCount.concat(' + ').concat( (aEClass.getFeatureCount() - baseClass.getFeatureCount()).toString() )
    endif
/]
[query public getFeatureIDName(anEClass : EClass ,aStructural : EStructuralFeature) : String = anEClass.getClassifierIDName().concat('__').concat( splitAndCombineWords(aStructural.name,'_')).toUpperCase() /]
[query public getFeatureValue( aEClass : EClass , aEFeature : EStructuralFeature ) : String =
    let index : Integer = aEClass.eAllStructuralFeatures->indexOf(aEFeature) - 1 in
    let baseClass : EClass = aEClass.getBaseClass() in
    if baseClass.oclIsUndefined() then
        index.toString()
    else
        let baseCount : Integer = baseClass.getFeatureCount() in
        if ( index < baseCount ) then
            if baseClass.ePackage = aEClass.ePackage then baseClass.getFeatureIDName( aEFeature ) else baseClass.getFeatureIDName( aEFeature ) endif
        else
            let baseCountID : String = if aEClass.ePackage = baseClass.ePackage then baseClass.getFeatureCountID() else baseClass.getFeatureCountID() endif in
            baseCountID.concat(' + ').concat( (index-baseCount).toString())
        endif 
    endif 
/]
[query public getFeatureKind( aEFeature : EStructuralFeature ) : String = 
    let kind : String =
    if aEFeature.oclIsKindOf(EReference) then 
        let eRef : EReference = aEFeature.oclAsType(EReference) in
        if ( eRef.containment ) then
            if ( isMap( aEFeature.eType.instanceClassName )) then 
                'map'
            else 
                'containment reference' 
            endif
        else if ( eRef.container ) then
            'container reference'
        else
            'reference'
        endif endif
    else
        'attribute'
    endif in
    if ( not(kind = 'map') ) and aEFeature.many then
        kind.concat(' list')
    else
        kind
    endif
/]
[query private isMap(  aEFeature : EStructuralFeature , n : String  ) : Boolean = let entries : Sequence(String) = Sequence{'java.util.Map.Entry','java.util.Map$Entry'} in entries->includes(n)/]
[query public getQualifiedFeatureIDName( aStructuralFeature : EStructuralFeature ) : String =
    aStructuralFeature.getPackageName(aStructuralFeature.eContainingClass) + '::' + aStructuralFeature.eContainingClass.getFeatureIDName( aStructuralFeature )
/]

[query public getOperationCountID( aEClass : EClass ) : String = aEClass.getClassifierIDName().concat('_OPERATION_COUNT')/]
[query public getOperationCountValue( aEClass : EClass ) : String = 
    let baseClass : EClass = aEClass.getBaseClass() in
    if baseClass.oclIsUndefined() then
        aEClass.getOperationCount()
    else
        let baseCount : String = if baseClass.ePackage = aEClass.ePackage then baseClass.getOperationCountID() else baseClass.getOperationCountID() endif in
        baseCount.concat(' + ').concat( (aEClass.getOperationCount() - baseClass.getOperationCount()).toString() )
    endif
/]
[query public getOperationIDName(anEClass : EClass ,aOperation : EOperation) : String = anEClass.getClassifierIDName().concat('__').concat( splitAndCombineWords(aOperation.name , '_')).concat(aOperation.getParameterListName()).toUpperCase() /]
[query public getOperationValue(aEClass : EClass , aOperation : EOperation ) : String = 
    let index : Integer = aEClass.eAllOperations->indexOf(aOperation) - 1 in
    let baseClass : EClass = aEClass.getBaseClass() in
    if baseClass.oclIsUndefined() then
        index.toString()
    else
        let baseCount : Integer = baseClass.getOperationCount() in
        if ( index < baseCount ) then
            if baseClass.ePackage = aEClass.ePackage then baseClass.getOperationIDName( aOperation ) else baseClass.getOperationIDName( aOperation ) endif
        else
            let baseCountID : String = if aEClass.ePackage = baseClass.ePackage then baseClass.getOperationCountID() else baseClass.getOperationCountID() endif in
            baseCountID.concat(' + ').concat( (index-baseCount).toString())
        endif 
    endif 
/]
[query public getQualifiedOperationIDName( aOperation : EOperation ) : String =
    aOperation.getPackageName(aOperation.eContainingClass) + '::' + aOperation.eContainingClass.getOperationIDName( aOperation )
/]

[**
 * Feature / Operation accessors visibility
*/]
[query public getVisibilityType( aEModelElement : EModelElement , aImplementation : Boolean ) : String = getVisibilityType(aEModelElement, null, aImplementation)/]
[query public getVisibilityType( aEModelElement : EModelElement , aAccessor : String, aImplementation : Boolean ) : String =
    let key : String = if aAccessor.oclIsUndefined() then 'visibility' else aAccessor.concat('Visibility') endif in   
    if hasKey( key ) then
        let value : String = valueKey( key ) in
        let index : Integer = value.index( ':' ) in
        if ( index = -1 ) then
            value
        else
            if ( aImplementation ) then
                value.substring( index + 1 )
            else
                value.substring(1 , index - 1 )
            endif
        endif
    else 
        'public'
    endif
/]

[query public hasSetter(aStructuralFeature : EStructuralFeature , aVisibility : String , aImplementation : Boolean ) : Boolean = isSet() and aStructuralFeature.getVisibilityType('set',aImplementation ) = aVisibility /]
[query public hasGetter(aStructuralFeature : EStructuralFeature , aVisibility : String , aImplementation : Boolean) : Boolean = isGet() and aStructuralFeature.getVisibilityType('get', aImplementation ) = aVisibility /]
[query public hasUnSetter(aStructuralFeature : EStructuralFeature , aVisibility : String , aImplementation : Boolean) : Boolean = isUnSet() and aStructuralFeature.getVisibilityType('unset', aImplementation ) = aVisibility /]
[query public hasIsSet(aStructuralFeature : EStructuralFeature , aVisibility : String , aImplementation : Boolean) : Boolean = isIsSet() and aStructuralFeature.getVisibilityType('isset', aImplementation ) = aVisibility /]

[query public isPublic( anEOperation : EOperation, aImplementation: Boolean ) : Boolean = anEOperation.getVisibilityType(aImplementation) = 'public'/]

[query public isVoid(aOperation : EOperation) : Boolean = aOperation.eType.oclIsUndefined() /]

[**
 * Classes Onthology
*/]
[query public hasExtension( aEClass : EClass ) : Boolean = hasKey('extension') and valueKey('extension' )='true'/]

[query public getOrderedClasses( anEPackage : EPackage ) : Sequence(EClass) = invoke('soft.generator.cpp.utils.GenerateUtils','getOrderedClasses(org.eclipse.emf.ecore.EPackage)',Sequence{anEPackage}) /]

[query public getBaseClass( aEClass : EClass ) : EClass = if (aEClass.eSuperTypes->isEmpty() ) then null else aEClass.eSuperTypes->first() endif/]

[query public getInterfaceExtends(aClass : EClass ) : Sequence(String) =
    let qualifiedInterfaces : Sequence(String) = aClass.eSuperTypes->collect(c | c.getQualifiedInterfaceName() ) in
    if ( qualifiedInterfaces->isEmpty() ) then
        if ( aClass.name = 'EObject' ) then
            qualifiedInterfaces->prepend('ecore::ENotifier')
        else
            qualifiedInterfaces->prepend('ecore::EObject')
        endif
    else
        qualifiedInterfaces
    endif 
/]

[query public getClassExtends(aClass : EClass ) : String = 
    let extendsClass : EClass = aClass.getClassExtendsClass() in
    if ( extendsClass.oclIsUndefined() ) then
        if ( aClass.name = 'EObject' ) then
            'ecore::impl::BasicEObject'
        else
            'ecore::impl::EObjectImpl'
        endif
    else
        if ( extendsClass.hasExtension() ) then
            extendsClass.getQualifiedExtensionName()
        else
            extendsClass.getQualifiedImplementationName()
        endif
    endif
/]

[query public getClassImplements(aClass : EClass ) : Sequence(String) = Sequence{ aClass.getQualifiedInterfaceName() }/]

[query private getClassExtendsClass( aClass : EClass ) : EClass = getClassExtendsClass( aClass , aClass.getBaseClass() )/]
[query private getClassExtendsClass( aClass : EClass , aBaseClass : EClass ) : EClass =
    if ( aClass = aBaseClass ) then
        null
    else
        if ( aBaseClass.oclIsUndefined() or (not aBaseClass.interface) ) then
            aBaseClass
        else
            getClassExtendsClass(aClass , aBaseClass.getBaseClass())
        endif
    endif
/]

[query public getClassIncludes(aClass : EClass) : Set(EClassifier) = OrderedSet{aClass.eSuperTypes,aClass.eAllStructuralFeatures.eType,aClass.eOperations.eType,aClass.eOperations.eParameters.eType}->flatten() /]

[query public getMockExtends(aClass : EClass ) : String =
    let extendsClass : EClass = aClass.getClassExtendsClass() in
    if ( extendsClass.oclIsUndefined() ) then
        if ( aClass.name = 'EObject' ) then
            'ecore::tests::MockNotifier'
        else
            'ecore::tests::MockObject'
        endif
    else
        extendsClass.getQualifiedMockName()
    endif 
/]

[query public getMockImplements(aClass : EClass ) : Sequence(String) = Sequence{ aClass.getQualifiedInterfaceName() }/]
